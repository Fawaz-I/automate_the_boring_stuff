<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="../assets/automatetheboringstuff.com/3e/style.css" rel="stylesheet" type="text/css" /><title>Chapter 9 - Text Pattern Matching with Regular Expressions, Automate the Boring Stuff with Python, 3rd Ed</title></head><body><style>.atbs-nav{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;justify-content:space-between;margin:1rem 0;padding:.7rem .8rem;border:1px solid #cfd8dc;border-radius:10px;background:#f6fbfd;font:14px/1.35 system-ui,-apple-system,sans-serif;}.atbs-nav-center{color:#455a64;font-weight:600;}.atbs-nav-link{text-decoration:none;color:#0b5b6b;background:#e6f3f7;border:1px solid #c7dfe7;border-radius:7px;padding:.42rem .55rem;display:inline-block;}.atbs-nav-link:hover{background:#d9edf3;}.atbs-nav-disabled{opacity:.55;cursor:not-allowed;}</style><nav class='atbs-nav' aria-label='Chapter pagination'><a class='atbs-nav-link' href='../workbook/chapter8.html' aria-label='Previous chapter'>&larr; Workbook Chapter 8</a><span class='atbs-nav-center'><a class='atbs-nav-link' href='../index.html'>Contents</a> Book Chapter 9</span><a class='atbs-nav-link' href='../workbook/chapter9.html' aria-label='Next chapter'>Workbook Chapter 9 &rarr;</a></nav><div type="frontmatter" class="calibre" id="calibre_link-0">





<div type="bodymatter" class="calibre" id="calibre_link-189">
<section type="chapter" role="doc-chapter" aria-labelledby="ch9">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1623" aria-label="185"></span>
<hgroup>
<h2 class="title" id="calibre_link-1624">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">9</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">TEXT PATTERN MATCHING WITH REGULAR EXPRESSIONS</span></span>
</h2>
</hgroup>
<figure class="opener"><img class="opener1" src="../assets/automatetheboringstuff.com/3e/images/000112.jpg" role="presentation" alt="" />
</figure>
<p class="introtni">You may be familiar with the process of searching for text by pressing <small class="calibre19">CTRL</small>-F and entering the words you’re looking for. <i class="calibre18">Regular expressions</i> go one step further: they allow you to specify a pattern of text to search for. You may not know a business’s exact phone number, but if you live in the United States or Canada, you know it will consist of a three-digit area code, followed by a hyphen, then three more digits, another hyphen, and four more digits. This is how you, as a human, know a phone number when you see it: 415-555-1234 is a phone number, but $4,155,551,234 is not.</p>
<p class="tx">We recognize all sorts of other text patterns every day: email addresses have @ symbols in the middle, US Social Security numbers have nine digits and two hyphens, website URLs often have periods and forward slashes, <span role="doc-pagebreak" type="pagebreak" id="calibre_link-1114" aria-label="186"></span>news headlines use title case, and social media hashtags begin with # and contain no spaces, to give some examples.</p>
<p class="tx">Regular expressions are helpful, but few nonprogrammers know about them, even though most modern text editors and word processors have find-and-replace features that can search based on regular expressions. Regular expressions are huge time-savers, not just for software users but also for programmers. In fact, in the <i class="calibre5">Guardian</i> article “Here’s What ICT Should Really Teach Kids: How to Do Regular Expressions,” tech writer Cory Doctorow argues that we should be teaching regular expressions before we teach programming:</p>
<p class="blockquote">Knowing [regular expressions] can mean the difference between solving a problem in 3 steps and solving it in 3,000 steps. When you’re a nerd, you forget that the problems you solve with a couple keystrokes can take other people days of tedious, error-prone work to slog through.</p>
<p class="tx">In this chapter, you’ll start by writing a program to find text patterns <i class="calibre5">without</i> using regular expressions and then learn how to use regular expressions to make the code simpler. I’ll show you basic matching with regular expressions, then move on to some more powerful features, such as string substitution and creating your own character classes. You’ll also learn how to use the Humre module, which offers plain-English substitutes for regular expressions’ cryptic symbol-based syntax.</p>
<section type="division" aria-labelledby="sec1">
<h3 class="h" id="calibre_link-1625"><span id="calibre_link-190"></span><span class="sans_futura_std_bold_b_">Finding Text Patterns Without Regular Expressions</span></h3>
<p class="tni">Say you want to find a US phone number in a string; you’re looking for three numbers, a hyphen, three numbers, a hyphen, and four numbers. Here’s an example: 415-555-4242.</p>
<p class="tx">Let’s write a function named <span class="thesansmonocd_w5regular_">is_phone_number()</span> to check whether a string matches this pattern and return either <span class="thesansmonocd_w5regular_">True</span> or <span class="thesansmonocd_w5regular_">False</span>. Open a new file editor tab and enter the following code, then save the file as <i class="calibre5">isPhoneNumber.py</i>:</p>
<pre class="pre"><code class="calibre9">def is_phone_number(text):
  <span class="code_codeannotation" aria-label="annotation1">❶</span> if len(text) != 12:  # Phone numbers have exactly 12 characters.
        return False
    for i in range(0, 3):  # The first three characters must be numbers.
      <span class="code_codeannotation" aria-label="annotation2">❷</span> if not text[i].isdecimal():
            return False
  <span class="code_codeannotation" aria-label="annotation3">❸</span> if text[3] != '-':  # The fourth character must be a dash.
        return False
    for i in range(4, 7): # The next three characters must be numbers.
      <span class="code_codeannotation" aria-label="annotation4">❹</span> if not text[i].isdecimal():
            return False
  <span class="code_codeannotation" aria-label="annotation5">❺</span> if text[7] != '-':  # The eighth character must be a dash.
        return False
    for i in range(8, 12):  # The next four characters must be numbers.
      <span class="code_codeannotation" aria-label="annotation6">❻</span> if not text[i].isdecimal():
            return False
  <span class="code_codeannotation" aria-label="annotation7">❼</span> return True

<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1626" aria-label="187"></span>print('Is 415-555-4242 a phone number?', is_phone_number('415-555-4242'))
print(is_phone_number('415-555-4242'))
print('Is Moshi moshi a phone number?', is_phone_number('Moshi moshi'))
print(is_phone_number('Moshi moshi'))
</code></pre>
<p class="tx">When this program is run, the output looks like this:</p>
<pre class="pre"><code class="calibre9">Is 415-555-4242 a phone number?
True
Is Moshi moshi a phone number?
False
</code></pre>
<p class="tx">The <span class="thesansmonocd_w5regular_">is_phone_number()</span> function has code that does several checks to determine whether the string in <span class="thesansmonocd_w5regular_">text</span> is a valid phone number. If any of these checks fail, the function returns <span class="thesansmonocd_w5regular_">False</span>. First, the code checks that the string is exactly 12 characters long <span class="codeannotation" aria-label="annotation1">❶</span>. Then, it checks that the area code (that is, the first three characters in <span class="thesansmonocd_w5regular_">text</span>) consists of only numeric characters <span class="codeannotation" aria-label="annotation2">❷</span> by calling the <span class="thesansmonocd_w5regular_">isdecimal()</span> string method. The rest of the function checks that the string follows the pattern of a phone number: the number must have the first hyphen after the area code <span class="codeannotation" aria-label="annotation3">❸</span>, three more numeric characters <span class="codeannotation" aria-label="annotation4">❹</span>, another hyphen <span class="codeannotation" aria-label="annotation5">❺</span>, and finally, four more numeric characters <span class="codeannotation" aria-label="annotation6">❻</span>. If the program execution manages to get past all the checks, it returns <span class="thesansmonocd_w5regular_">True</span> <span class="codeannotation" aria-label="annotation7">❼</span>.</p>
<p class="tx">Calling <span class="thesansmonocd_w5regular_">is_phone_number()</span> with the argument <span class="thesansmonocd_w5regular_">'415-555-4242'</span> will return <span class="thesansmonocd_w5regular_">True</span>. Calling <span class="thesansmonocd_w5regular_">is_phone_number()</span> with <span class="thesansmonocd_w5regular_">'Moshi moshi'</span> will return <span class="thesansmonocd_w5regular_">False</span>; the first test fails because <span class="thesansmonocd_w5regular_">'Moshi moshi'</span> is not 12 characters long.</p>
<p class="tx">If you wanted to find a phone number within a larger string, you would have to add even more code to locate the pattern. Replace the last four <span class="thesansmonocd_w5regular_">print()</span> function calls in <i class="calibre5">isPhoneNumber.py</i> with the following:</p>
<pre class="pre"><code class="calibre9">message = 'Call me at 415-555-1011 tomorrow. 415-555-9999 is my office.'
for i in range(len(message)):
  <span class="code_codeannotation" aria-label="annotation1">❶</span> segment = message[i:i+12]
  <span class="code_codeannotation" aria-label="annotation2">❷</span> if is_phone_number(segment):
        print('Phone number found: ' + segment)
print('Done')
</code></pre>
<p class="tx">When this program is run, the output will look like this:</p>
<pre class="pre"><code class="calibre9">Phone number found: 415-555-1011
Phone number found: 415-555-9999
Done
</code></pre>
<p class="tx">On each iteration of the <span class="thesansmonocd_w5regular_">for</span> loop, a new segment of 12 characters from <span class="thesansmonocd_w5regular_">message</span> is assigned to the variable <span class="thesansmonocd_w5regular_">segment</span> <span class="codeannotation" aria-label="annotation1">❶</span>. For example, on the first iteration, <span class="thesansmonocd_w5regular_">i</span> is <span class="thesansmonocd_w5regular_">0</span>, and <span class="thesansmonocd_w5regular_">segment</span> is assigned <span class="thesansmonocd_w5regular_">message[0:12]</span> (that is, the string <span class="thesansmonocd_w5regular_">'Call me at 4'</span>). On the next iteration, <span class="thesansmonocd_w5regular_">i</span> is <span class="thesansmonocd_w5regular_">1</span>, and <span class="thesansmonocd_w5regular_">segment</span> is assigned <span class="thesansmonocd_w5regular_">message[1:13]</span> (the string <span class="thesansmonocd_w5regular_">'all me at 41'</span>). In other words, on each iteration of the <span class="thesansmonocd_w5regular_">for</span> loop, <span class="thesansmonocd_w5regular_">segment</span> takes on the following values</p>
<pre class="pre"><code class="calibre9">'Call me at 4'
'all me at 41'
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1044" aria-label="188"></span>'ll me at 415'
'l me at 415-'
</code></pre>
<p class="tni">and so on, until its last value is <span class="thesansmonocd_w5regular_">'s my office.'</span></p>
<p class="tx">The loop’s code passes <span class="thesansmonocd_w5regular_">segment</span> to <span class="thesansmonocd_w5regular_">is_phone_number()</span> to check whether it matches the phone number pattern <span class="codeannotation" aria-label="annotation2">❷</span>, and if so, it prints the segment. Once it has finished going through <span class="thesansmonocd_w5regular_">message</span>, we print <span class="thesansmonocd_w5regular_">Done</span>.</p>
<p class="tx">While the string in <span class="thesansmonocd_w5regular_">message</span> is short in this example, the program would run in less than a second even if it were millions of characters long. A similar program that finds phone numbers using regular expressions would also run in less than a second; however, regular expressions make writing these programs much quicker.</p>
</section>
<section type="division" aria-labelledby="sec2">
<h3 class="h" id="calibre_link-1627"><span id="calibre_link-191"></span><span class="sans_futura_std_bold_b_">Finding Text Patterns with Regular Expressions</span></h3>
<p class="tni">The previous phone number&ndash;finding program works, but it uses a lot of code to do something limited. The <span class="thesansmonocd_w5regular_">is_phone_number()</span> function is 17 lines but can find only one phone number format. What about a phone number formatted like 415.555.4242 or (415) 555-4242? And what if the phone number had an extension, like 415-555-4242 x99? The <span class="thesansmonocd_w5regular_">is_phone_number()</span> function would fail to find them. You could add yet more code for these additional patterns, but there is an easier way to tackle the problem.</p>
<p class="tx">Regular expressions, called <i class="calibre5">regexes</i> for short, are a sort of mini language that describes a pattern of text. For example, the characters <span class="thesansmonocd_w5regular_">\d</span> in a regex stand for a decimal numeral between 0 and 9. Python uses the regex string <span class="thesansmonocd_w5regular_">r'\d\d\d-\d\d\d-\d\d\d\d'</span> to match the same text pattern the previous <span class="thesansmonocd_w5regular_">is_phone_number()</span> function did: a string of three numbers, a hyphen, three more numbers, another hyphen, and four numbers. Any other string would not match the <span class="thesansmonocd_w5regular_">r'\d\d\d-\d\d\d-\d\d\d\d'</span> regex.</p>
<p class="tx">Regular expressions can be much more sophisticated than this one. For example, adding a numeral, such as 3, in curly brackets (<span class="thesansmonocd_w5regular_">{3}</span>) after a pattern is like saying, “Match this pattern three times.” So the slightly shorter regex <span class="thesansmonocd_w5regular_">r'\d{3}-\d{3}-\d{4}'</span> also matches the phone number pattern.</p>
<p class="tx">Note that we often write regex strings as raw strings, with the <span class="thesansmonocd_w5regular_">r</span> prefix. This is useful, as regex strings often have backslashes. Without using raw strings, we would have to enter expressions such as <span class="thesansmonocd_w5regular_">'\\d'</span>.</p>
<p class="tx">Before we cover all of the details of regular expression syntax, let’s go over how to use them in Python. We’ll stick with the example regular expression string <span class="thesansmonocd_w5regular_">r'\d{3}-\d{3}-\d{4}'</span> used to find US phone numbers in a text string <span class="thesansmonocd_w5regular_">'My number is 415-555-4242'</span>. The general process of using regular expressions in Python involves four steps:</p>
<p class="listnumberf">  1.  Import the <span class="thesansmonocd_w5regular_">re</span> module.</p>
<p class="listnumber">  2.  Pass the regex string to <span class="thesansmonocd_w5regular_">re.compile()</span> to get a <span class="thesansmonocd_w5regular_">Pattern</span> object.</p>
<p class="listnumber"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1136" aria-label="189"></span>  3.  Pass the text string to the <span class="thesansmonocd_w5regular_">Pattern</span> object’s <span class="thesansmonocd_w5regular_">search()</span> method to get a <span class="thesansmonocd_w5regular_">Match</span> object.</p>
<p class="listnumberl">  4.  Call the <span class="thesansmonocd_w5regular_">Match</span> object’s <span class="thesansmonocd_w5regular_">group()</span> method to get the string of the matched text.</p>
<p class="tx">In the interactive shell, these steps look like this:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">phone_num_pattern_obj = re.compile(r'\d{3}-\d{3}-\d{4}')</b>
&gt;&gt;&gt; <b class="calibre10">match_obj = phone_num_pattern_obj.search('My number is 415-555-4242.')</b>
&gt;&gt;&gt; <b class="calibre10">match_obj.group()</b>
'415-555-4242'
</code></pre>
<p class="tx">All regex functions in Python are in the <span class="thesansmonocd_w5regular_">re</span> module. Most of the examples in this chapter will require the <span class="thesansmonocd_w5regular_">re</span> module, so remember to import it at the beginning of the program. Otherwise, you’ll get a <span class="thesansmonocd_w5regular_">NameError: name 're' is not defined</span> error message. As with importing any module, you need to import it only once per program or interactive shell session.</p>
<p class="tx">Passing the regular expression string to <span class="thesansmonocd_w5regular_">re.compile()</span> returns a <span class="thesansmonocd_w5regular_">Pattern</span> object. You only need to compile the <span class="thesansmonocd_w5regular_">Pattern</span> object once; after that, you can call the <span class="thesansmonocd_w5regular_">Pattern</span> object’s <span class="thesansmonocd_w5regular_">search()</span> method for as many different text strings as you want.</p>
<p class="tx">A <span class="thesansmonocd_w5regular_">Pattern</span> object’s <span class="thesansmonocd_w5regular_">search()</span> method searches the string it is passed for any matches to the regex. The <span class="thesansmonocd_w5regular_">search()</span> method will return <span class="thesansmonocd_w5regular_">None</span> if the regex pattern isn’t found in the string. If the pattern <i class="calibre5">is</i> found, the <span class="thesansmonocd_w5regular_">search()</span> method returns a <span class="thesansmonocd_w5regular_">Match</span> object, which will have a <span class="thesansmonocd_w5regular_">group()</span> method that returns a string of the matched text.</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_1">NOTE</span></p>
</blockquote>
<p class="note-txt"><i class="calibre5">While I encourage you to enter the example code into the interactive shell, you could also make use of web-based regular expression testers, which can show you exactly how a regex matches a piece of text that you enter. I recommend the testers at</i> <span class="dedication_italic"><a href="https://pythex.org" class="calibre1">https://<wbr></wbr>pythex<wbr></wbr>.org</a></span> <i class="calibre5">and</i> <span class="dedication_italic"><a href="https://regex101.com" class="calibre1">https://<wbr></wbr>regex101<wbr></wbr>.com</a></span><i class="calibre5">. Different programming languages have slightly different regular expression syntax, so be sure to select the “Python” flavor on these websites.</i></p>
</section>
<section type="division" aria-labelledby="sec3">
<h3 class="h" id="calibre_link-1628"><span id="calibre_link-192"></span><span class="sans_futura_std_bold_b_">The Syntax of Regular Expressions</span></h3>
<p class="tni">Now that you know the basic steps for creating and finding regular expression objects using Python, you’re ready to learn the full range of regular expression syntax. In this section, you’ll learn how to group regular expression elements together with parentheses, escape special characters, match several alternative groups with the pipe character, and return all matches with the <span class="thesansmonocd_w5regular_">findall()</span> method.</p>
<section type="division" aria-labelledby="sec4">
<h4 class="h1" id="calibre_link-1629"><span id="calibre_link-193"></span><span class="sans_futura_std_heavy_oblique_bi_">Grouping with Parentheses</span></h4>
<p class="tni">Say you want to separate one smaller part of the matched text, such as the area code, from the rest of the phone number (to, for example, perform some operation on it). Adding parentheses will create <i class="calibre5">groups</i> in the regex <span role="doc-pagebreak" type="pagebreak" id="calibre_link-844" aria-label="190"></span>string: <span class="thesansmonocd_w5regular_">r'(\d\d\d)-(\d\d\d-\d\d\d\d)'</span>. Then, you can use the <span class="thesansmonocd_w5regular_">group()</span> method of <span class="thesansmonocd_w5regular_">Match</span> objects to grab the matching text from just one group.</p>
<p class="tx">The first set of parentheses in a regex string will be group <span class="thesansmonocd_w5regular_">1</span>. The second set will be group <span class="thesansmonocd_w5regular_">2</span>. By passing the integer <span class="thesansmonocd_w5regular_">1</span> or <span class="thesansmonocd_w5regular_">2</span> to the <span class="thesansmonocd_w5regular_">group()</span> method, you can grab different parts of the matched text. Passing <span class="thesansmonocd_w5regular_">0</span> or nothing to the <span class="thesansmonocd_w5regular_">group()</span> method will return the entire matched text. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">phone_re = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')</b>
&gt;&gt;&gt; <b class="calibre10">mo = phone_re.search('My number is 415-555-4242.')</b>
&gt;&gt;&gt; <b class="calibre10">mo.group(1)</b>  # Returns the first group of the matched text
'415'
&gt;&gt;&gt; <b class="calibre10">mo.group(2)</b>  # Returns the second group of the matched text
'555-4242'
&gt;&gt;&gt; <b class="calibre10">mo.group(0)</b>  # Returns the full matched text
'415-555-4242'
&gt;&gt;&gt; <b class="calibre10">mo.group()</b>  # Also returns the full matched text
'415-555-4242'
</code></pre>
<p class="tx">If you would like to retrieve all the groups at once, use the <span class="thesansmonocd_w5regular_">groups()</span> method (note the plural form in the name):</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">mo.groups()</b>
('415', '555-4242')
&gt;&gt;&gt; <b class="calibre10">area_code, main_number = mo.groups()</b>
&gt;&gt;&gt; <b class="calibre10">print(area_code)</b>
415
&gt;&gt;&gt; <b class="calibre10">print(main_number)</b>
555-4242
</code></pre>
<p class="tx">Because <span class="thesansmonocd_w5regular_">mo.groups()</span> returns a tuple of multiple values, you can use the multiple-assignment trick to assign each value to a separate variable, as in the previous <span class="thesansmonocd_w5regular_">area_code, main_number</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">mo.groups()</span> line.</p>
</section>
<section type="division" aria-labelledby="sec5">
<h4 class="h1" id="calibre_link-1630"><span id="calibre_link-194"></span><span class="sans_futura_std_heavy_oblique_bi_">Using Escape Characters</span></h4>
<p class="tni">Parentheses create groups in regular expressions and are not interpreted as part of the text pattern. So, what do you do if you need to match a parenthesis in your text? For instance, maybe the phone numbers you are trying to match have the area code set in parentheses: <span class="thesansmonocd_w5regular_">'(415) 555-4242'</span>.</p>
<p class="tx">In this case, you need to escape the <span class="thesansmonocd_w5regular_">(</span>and) characters with a backslash. The <span class="thesansmonocd_w5regular_">\(</span>and <span class="thesansmonocd_w5regular_">\)</span> escaped parentheses will be interpreted as part of the pattern you are matching. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'(\(\d\d\d\)) (\d\d\d-\d\d\d\d)')</b>
&gt;&gt;&gt; <b class="calibre10">mo = pattern.search('My phone number is (415) 555-4242.')</b>
&gt;&gt;&gt; <b class="calibre10">mo.group(1)</b>
'(415)'
&gt;&gt;&gt; <b class="calibre10">mo.group(2)</b>
'555-4242'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-863" aria-label="191"></span>The <span class="thesansmonocd_w5regular_">\(</span>and <span class="thesansmonocd_w5regular_">\)</span> escape characters in the raw string passed to <span class="thesansmonocd_w5regular_">re.compile()</span> will match actual parenthesis characters. In regular expressions, the following characters have special meanings:</p>
<pre class="pre"><code class="calibre9">$ () * + - . ? [\] ^ {|}</code></pre>
<p class="tx">If you want to detect these characters as part of your text pattern, you need to escape them with a backslash:</p>
<pre class="pre"><code class="calibre9">\$ \(\) \* \+ \- \. \? \[\\ \] \^ \{\| \}</code></pre>
<p class="tx">Always double-check that you haven’t mistaken escaped parentheses <span class="thesansmonocd_w5regular_">\(</span>and <span class="thesansmonocd_w5regular_">\)</span> for unescaped parentheses <span class="thesansmonocd_w5regular_">(</span>and) in a regular expression. If you receive an error message about “missing)” or “unbalanced parenthesis,” you may have forgotten to include the closing unescaped parenthesis for a group, like in this example:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">re.compile(r'(\(Parentheses\)')</b>
Traceback (most recent call last):
<var class="calibre20">--snip--</var>
re.error: missing), unterminated subpattern at position 0
</code></pre>
<p class="tx">The error message tells you that there is an opening parenthesis at index <span class="thesansmonocd_w5regular_">0</span> of the <span class="thesansmonocd_w5regular_">r'(\(Parentheses\)'</span> string that is missing its corresponding closing parenthesis. Using the Humre module described later in this chapter helps prevent these kinds of typos.</p>
</section>
<section type="division" aria-labelledby="sec6">
<h4 class="h1" id="calibre_link-1631"><span id="calibre_link-195"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching Characters from Alternate Groups</span></h4>
<p class="tni">The <span class="thesansmonocd_w5regular_">|</span> character is called a <i class="calibre5">pipe</i>, and it’s used as the <i class="calibre5">alternation operator</i> in regular expressions. You can use it anywhere you want to match one of multiple expressions. For example, the regular expression <span class="thesansmonocd_w5regular_">r'Cat|Dog'</span> will match either <span class="thesansmonocd_w5regular_">'Cat'</span> or <span class="thesansmonocd_w5regular_">'Dog'</span>.</p>
<p class="tx">You can also use the pipe to match one of several patterns as part of your regex. For example, say you wanted to match any of the strings <span class="thesansmonocd_w5regular_">'Caterpillar'</span>, <span class="thesansmonocd_w5regular_">'Catastrophe'</span>, <span class="thesansmonocd_w5regular_">'Catch'</span>, or <span class="thesansmonocd_w5regular_">'Category'</span>. Since all of these strings start with <span class="thesansmonocd_w5regular_">Cat</span>, it would be nice if you could specify that prefix only once. You can do this by using the pipe within parentheses to separate the possible suffixes. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'Cat(erpillar|astrophe|ch|egory)')</b>
&gt;&gt;&gt; <b class="calibre10">match = pattern.search('Catch me if you can.')</b>
&gt;&gt;&gt; <b class="calibre10">match.group()</b>
'Catch'
&gt;&gt;&gt; <b class="calibre10">match.group(1)</b>
'ch'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1156" aria-label="192"></span>The method call <span class="thesansmonocd_w5regular_">match.group()</span> returns the full matched text <span class="thesansmonocd_w5regular_">'Catch'</span>, while <span class="thesansmonocd_w5regular_">match.group(1)</span> returns just the part of the matched text inside the first parentheses group, <span class="thesansmonocd_w5regular_">'ch'</span>. By using the pipe character and grouping parentheses, you can specify several alternative patterns you would like your regex to match.</p>
<p class="tx">If you need to match an actual pipe character, escape it with a backslash, like <span class="thesansmonocd_w5regular_">\|</span>.</p>
</section>
<section type="division" aria-labelledby="sec7">
<h4 class="h1" id="calibre_link-1632"><span id="calibre_link-196"></span><span class="sans_futura_std_heavy_oblique_bi_">Returning All Matches</span></h4>
<p class="tni">In addition to a <span class="thesansmonocd_w5regular_">search()</span> method, <span class="thesansmonocd_w5regular_">Pattern</span> objects have a <span class="thesansmonocd_w5regular_">findall()</span> method. While <span class="thesansmonocd_w5regular_">search()</span> will return a <span class="thesansmonocd_w5regular_">Match</span> object of the <i class="calibre5">first</i> matched text in the searched string, the <span class="thesansmonocd_w5regular_">findall()</span> method will return the strings of <i class="calibre5">every</i> match in the searched string.</p>
<p class="tx">There is one detail you need to keep in mind when using <span class="thesansmonocd_w5regular_">findall()</span>. The method returns a list of strings <i class="calibre5">as long as there are no groups in the regular expression</i>. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'\d{3}-\d{3}-\d{4}')  </b># This regex has no groups.
&gt;&gt;&gt; <b class="calibre10">pattern.findall('Cell: 415-555-9999 Work: 212-555-0000')</b>
['415-555-9999', '212-555-0000']
</code></pre>
<p class="tx">If there <i class="calibre5">are</i> groups in the regular expression, then <span class="thesansmonocd_w5regular_">findall()</span> will return a list of tuples. Each tuple represents a single match, and the tuple has strings for each group in the regex. To see this behavior in action, enter the following into the interactive shell (and notice that the regular expression being compiled now has groups in parentheses):</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'(\d{3})-(\d{3})-(\d{4})')  </b># This regex has groups.
&gt;&gt;&gt; <b class="calibre10">pattern.findall('Cell: 415-555-9999 Work: 212-555-0000')</b>
[('415', '555', '9999'), ('212', '555', '0000')]
</code></pre>
<p class="tx">Also keep in mind that <span class="thesansmonocd_w5regular_">findall()</span> doesn’t overlap matches. For example, matching three numbers with the regex string <span class="thesansmonocd_w5regular_">r'\d{3}'</span> matches the first three numbers in <span class="thesansmonocd_w5regular_">'1234'</span> but not the last three:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'\d{3}')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.findall('1234')</b>
['123']
&gt;&gt;&gt; <b class="calibre10">pattern.findall('12345')</b>
['123']
&gt;&gt;&gt; <b class="calibre10">pattern.findall('123456')</b>
['123', '456']
</code></pre>
<p class="tx">Because the first three digits in <span class="thesansmonocd_w5regular_">'1234'</span> have been matched as <span class="thesansmonocd_w5regular_">'123'</span>, the digits <span class="thesansmonocd_w5regular_">'234'</span> won’t be included in further matches, even though they fit the <span class="thesansmonocd_w5regular_">r'\d{3}'</span> pattern.</p>
</section>
</section>
<section type="division" aria-labelledby="sec8">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-853" aria-label="193"></span>
<h3 class="h" id="calibre_link-1633"><span id="calibre_link-197"></span><span class="sans_futura_std_bold_b_">Qualifier Syntax: What Characters to Match</span></h3>
<p class="tni">Regular expressions are split into two parts: the <i class="calibre5">qualifiers</i> that dictate what characters you are trying to match followed by the <i class="calibre5">quantifiers</i> that dictate how many characters you are trying to match. In the <span class="thesansmonocd_w5regular_">r'\d{3}-\d{3}-\d{4}'</span> phone number regex string example we’ve been using, the <span class="thesansmonocd_w5regular_">r'\d'</span> and <span class="thesansmonocd_w5regular_">'-'</span> parts are qualifiers and the <span class="thesansmonocd_w5regular_">'{3}'</span> and <span class="thesansmonocd_w5regular_">'{4}'</span> are quantifiers. Let’s now examine the syntax of qualifiers.</p>
<section type="division" aria-labelledby="sec9">
<h4 class="h1" id="calibre_link-1634"><span id="calibre_link-198"></span><span class="sans_futura_std_heavy_oblique_bi_">Using Character Classes and Negative Character Classes</span></h4>
<p class="tni">Although you can define a single character to match, as we’ve done in the previous examples, you can also define a set of characters to match inside square brackets. This set is called a <i class="calibre5">character class</i>. For example, the character class <span class="thesansmonocd_w5regular_">[aeiouAEIOU]</span> will match any vowel, both lowercase and uppercase. It’s the equivalent of writing <span class="thesansmonocd_w5regular_">a|e|i|o|u|A|E|I|O|U</span>, but it’s easier to type. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">vowel_pattern = re.compile(r'[aeiouAEIOU]')</b>
&gt;&gt;&gt; <b class="calibre10">vowel_pattern.findall('RoboCop eats BABY FOOD.')</b>
['o', 'o', 'o', 'e', 'a', 'A', 'O', 'O']
</code></pre>
<p class="tx">You can also include ranges of letters or numbers by using a hyphen. For example, the character class <span class="thesansmonocd_w5regular_">[a-zA-Z0-9]</span> will match all lowercase letters, uppercase letters, and numbers.</p>
<p class="tx">Note that, inside the square brackets, the normal regular expression symbols are not interpreted as such. This means you do not need to escape characters such as parentheses inside the square brackets if you want to match literal parentheses. For example, the character class <span class="thesansmonocd_w5regular_">[()]</span> will match either an open or close parenthesis. You do not need to write this as <span class="thesansmonocd_w5regular_">[\(\)]</span>.</p>
<p class="tx">By placing a caret character (<span class="thesansmonocd_w5regular_">^</span>) just after the character class’s opening bracket, you can make a <i class="calibre5">negative character class</i>. A negative character class will match all the characters that are <i class="calibre5">not</i> in the character class. For example, enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">consonant_pattern = re.compile(r'[^aeiouAEIOU]')</b>
&gt;&gt;&gt; <b class="calibre10">consonant_pattern.findall('RoboCop eats BABY FOOD.')</b>
['R', 'b', 'C', 'p', ' ', 't', 's', ' ', 'B', 'B', 'Y', ' ', 'F', 'D', '.']
</code></pre>
<p class="tx">Now, instead of matching every vowel, we’re matching every character that isn’t a vowel. Keep in mind that this includes spaces, newlines, punctuation characters, and numbers.</p>
</section>
<section type="division" aria-labelledby="sec10">
<h4 class="h1" id="calibre_link-1635"><span id="calibre_link-199"></span><span class="sans_futura_std_heavy_oblique_bi_">Using Shorthand Character Classes</span></h4>
<p class="tni">In the earlier phone number regex example, you learned that <span class="thesansmonocd_w5regular_">\d</span> could stand for any numeric digit. That is, <span class="thesansmonocd_w5regular_">\d</span> is shorthand for the regular <span role="doc-pagebreak" type="pagebreak" id="calibre_link-857" aria-label="194"></span>expression <span class="thesansmonocd_w5regular_">0|1|2|3|4|5|6|7|8|9</span> or <span class="thesansmonocd_w5regular_">[0-9]</span>. There are many such <i class="calibre5">shorthand character classes</i>, as shown in Table 9-1.</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-725"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 9-1:</span></span> <span class="sans_futura_std_book_">Shorthand Codes for Common Character Classes</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Shorthand character class</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Represents ...</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">\d</span></p></td>
<td class="tbf"><p class="tch1"><span class="sans_futura_std_book_">Any numeric digit from 0 to 9.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">\D</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Any character that is</span> <span class="sans_futura_std_book_oblique_i_">not</span> <span class="sans_futura_std_book_">a numeric digit from 0 to 9.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">\w</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Any letter, numeric digit, or the underscore character. (Think of this as matching “word” characters.)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">\W</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Any character that is</span> <span class="sans_futura_std_book_oblique_i_">not</span> <span class="sans_futura_std_book_">a letter, numeric digit, or the underscore character.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">\s</span></p></td>
<td class="tb"><p class="tch1"><span class="sans_futura_std_book_">Any space, tab, or newline character. (Think of this as matching “space” characters.)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">\S</span></p></td>
<td class="tbl"><p class="tch1"><span class="sans_futura_std_book_">Any character that is</span> <span class="sans_futura_std_book_oblique_i_">not</span> <span class="sans_futura_std_book_">a space, tab, or newline character.</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">Note that while <span class="thesansmonocd_w5regular_">\d</span> matches digits and <span class="thesansmonocd_w5regular_">\w</span> matches digits, letters, and the underscore, there is no shorthand character class that matches only letters. Though you can use the <span class="thesansmonocd_w5regular_">[a-zA-Z]</span> character class, this character class won’t match accented letters or non-Roman alphabet letters such as <span class="thesansmonocd_w5regular_">'é'</span>. Also, remember to use raw strings to escape the backslash: <span class="thesansmonocd_w5regular_">r'\d'</span>.</p>
<p class="tx">For example, enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'\d+\s\w+')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.findall('12 drummers, 11 pipers, 10 lords, 9 ladies, 8 maids, </b>
<b class="calibre10">7 swans, 6 geese, 5 rings, 4 birds, 3 hens, 2 doves, 1 partridge')</b>
['12 drummers', '11 pipers', '10 lords', '9 ladies', '8 maids', '7 swans', '
6 geese', '5 rings', '4 birds', '3 hens', '2 doves', '1 partridge']
</code></pre>
<p class="tx">The regular expression <span class="thesansmonocd_w5regular_">\d+\s\w+</span> will match text that has one or more numeric digits (<span class="thesansmonocd_w5regular_">\d+</span>), followed by a whitespace character (<span class="thesansmonocd_w5regular_">\s</span>), followed by one or more letter/digit/underscore characters (<span class="thesansmonocd_w5regular_">\w+</span>). The <span class="thesansmonocd_w5regular_">findall()</span> method returns all matching strings of the regular expression pattern in a list.</p>
</section>
<section type="division" aria-labelledby="sec11">
<h4 class="h1" id="calibre_link-1636"><span id="calibre_link-200"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching Everything with the Dot Character</span></h4>
<p class="tni">The <span class="thesansmonocd_w5regular_">.</span> (or <i class="calibre5">dot</i>) character in a regular expression string matches any character except for a newline. For example, enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">at_re = re.compile(r'.at')</b>
&gt;&gt;&gt; <b class="calibre10">at_re.findall('The cat in the hat sat on the flat mat.')</b>
['cat', 'hat', 'sat', 'lat', 'mat']
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1232" aria-label="195"></span>Remember that the dot character will match just one character, which is why the text <span class="thesansmonocd_w5regular_">flat</span> in the previous example matched only <span class="thesansmonocd_w5regular_">lat</span>. To match an actual period, escape the dot with a backslash: <span class="thesansmonocd_w5regular_">\.</span></p>
</section>
<section type="division" aria-labelledby="sec12">
<h4 class="h1" id="calibre_link-1637"><span id="calibre_link-201"></span><span class="sans_futura_std_heavy_oblique_bi_">Being Careful What You Match For</span></h4>
<p class="tni">The best and worst thing about regular expressions is that they will match exactly what you ask for. Here are some common points of confusion regarding character classes:</p>
<ul class="ul">
<li class="bl">The <span class="thesansmonocd_w5regular_">[A-Z]</span> or <span class="thesansmonocd_w5regular_">[a-z]</span> character class matches uppercase or lowercase letters, respectively, but not both. You need to use <span class="thesansmonocd_w5regular_">[A-Za-z]</span> to match both cases.</li>
<li class="bl">The <span class="thesansmonocd_w5regular_">[A-Za-z]</span> character class matches only plain, unaccented letters. For example, the regex string <span class="thesansmonocd_w5regular_">r'First Name: ([A-Za-z]+)'</span> would match “First Name: ” followed by a group of one or more unaccented letters. But singer Sin<span>é</span>ad O’Connor’s first name would match up to the <i class="calibre5">é</i> only, and the group would be set to <span class="thesansmonocd_w5regular_">'Sin'</span>.</li>
<li class="bl">The <span class="thesansmonocd_w5regular_">\w</span> character class matches all letters, including accented letters and characters from other alphabets. But it also matches numbers and the underscore character, so the regex string <span class="thesansmonocd_w5regular_">r'First Name: (\w+)'</span> may match more than you intended.</li>
<li class="bl">The <span class="thesansmonocd_w5regular_">\w</span> character class matches all letters, but the regex string <span class="thesansmonocd_w5regular_">r'Last Name: (\w+)'</span> would capture Sin<span>é</span>ad O’Connor’s last name only up until the apostrophe character. This means the group would capture her last name as <span class="thesansmonocd_w5regular_">'O'</span>.</li>
<li class="bl">Straight and smart quote characters (<span class="thesansmonocd_w5regular_">' " ‘ ’ “ ”</span>) are considered completely different from each other and must be specified separately.</li>
</ul>
<p class="tx">Real-world data is complicated. Even if your program manages to capture Sin<span class="dedication_italic">é</span>ad O’Connor’s name, it could fail with Jean-Paul Sartre’s name because of the hyphen.</p>
<p class="tx">Of course, when software declares a name to be invalid input, it is the software, and not the name, that has a bug; people’s names cannot be invalid. You can learn more about this issue from Patrick McKenzie’s article “Falsehoods Programmers Believe About Names” at <i class="calibre5"><a href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.kalzumeus<wbr></wbr>.com<wbr></wbr>/2010<wbr></wbr>/06<wbr></wbr>/17<wbr></wbr>/falsehoods<wbr></wbr>-programmers<wbr></wbr>-believe<wbr></wbr>-about<wbr></wbr>-names<wbr></wbr>/</a></i>. This article spawned a genre of similar “falsehoods programmers believe” pieces about how software mishandles dates, time zones, currencies, postal addresses, genders, airport codes, and love. Watch Carina C. Zona’s 2015 PyCon talk on the topic, “Schemas for the Real World,” at <i class="calibre5"><a href="https://youtu.be/PYYfVqtcWQY" class="calibre1">https://<wbr></wbr>youtu<wbr></wbr>.be<wbr></wbr>/PYYfVqtcWQY</a></i>.</p>
</section>
</section>
<section type="division" aria-labelledby="sec13">
<h3 class="h" id="calibre_link-1638"><span id="calibre_link-202"></span><span class="sans_futura_std_bold_b_">Quantifier Syntax: How Many Qualifiers to Match</span></h3>
<p class="tni">In a regular expression string, quantifiers follow qualifier characters to dictate how many of them to match. For example, in the phone number regex considered earlier, the <span class="thesansmonocd_w5regular_">{3}</span> follows the <span class="thesansmonocd_w5regular_">\d</span> to match exactly three digits. If <span role="doc-pagebreak" type="pagebreak" id="calibre_link-868" aria-label="196"></span>there is no quantifier following a qualifier, the qualifier must appear exactly once: you can think of <span class="thesansmonocd_w5regular_">r'\d'</span> as being the same as <span class="thesansmonocd_w5regular_">r'\d{1}'</span>.</p>
<section type="division" aria-labelledby="sec14">
<h4 class="h1" id="calibre_link-1639"><span id="calibre_link-203"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching an Optional Pattern</span></h4>
<p class="tni">Sometimes you may want to match a pattern only optionally. That is, the regex should match zero or one of the preceding qualifiers. The <span class="thesansmonocd_w5regular_">?</span> character flags the preceding qualifier as optional. For example, enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'42!?')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.search('42!')</b>
&lt;re.Match object; span=(0, 3), match='42!'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('42')</b>
&lt;re.Match object; span=(0, 2), match='42'&gt;
</code></pre>
<p class="tx">The <span class="thesansmonocd_w5regular_">?</span> part of the regular expression means that the pattern <span class="thesansmonocd_w5regular_">!</span> is optional. So it matches both <span class="thesansmonocd_w5regular_">42!</span> (with the exclamation mark) and <span class="thesansmonocd_w5regular_">42</span> (without it).</p>
<p class="tx">As you’re beginning to see, regular expression syntax’s reliance on symbols and punctuation makes it tricky to read: the <span class="thesansmonocd_w5regular_">?</span> question mark has meaning in regex syntax, but the <span class="thesansmonocd_w5regular_">!</span> exclamation mark doesn’t. So <span class="thesansmonocd_w5regular_">r'42!?'</span> means <span class="thesansmonocd_w5regular_">'42'</span> optionally followed by a <span class="thesansmonocd_w5regular_">'!'</span>, but <span class="thesansmonocd_w5regular_">r'42?!'</span> means <span class="thesansmonocd_w5regular_">'4'</span> optionally followed by <span class="thesansmonocd_w5regular_">'2'</span> followed by <span class="thesansmonocd_w5regular_">'!'</span>:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'42?!')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.search('42!')</b>
&lt;re.Match object; span=(0, 3), match='42!'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('4!')</b>
&lt;re.Match object; span=(0, 2), match='4!'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('42') == None  </b># No match
True
</code></pre>
<p class="tx">To make multiple characters optional, place them in a group and put the <span class="thesansmonocd_w5regular_">?</span> after the group. In the earlier phone number example, you can use <span class="thesansmonocd_w5regular_">?</span> to make the regex look for phone numbers that either do or do not have an area code. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'(\d{3}-)?\d{3}-\d{4}')</b>
&gt;&gt;&gt; <b class="calibre10">match1 = pattern.search('My number is 415-555-4242')</b>
&gt;&gt;&gt; <b class="calibre10">match1.group()</b>
'415-555-4242'

&gt;&gt;&gt; <b class="calibre10">match2 = pattern.search('My number is 555-4242')</b>
&gt;&gt;&gt; <b class="calibre10">match2.group()</b>
'555-4242'
</code></pre>
<p class="tx">You can think of the <span class="thesansmonocd_w5regular_">?</span> as saying, “Match zero or one of the group preceding this question mark.”</p>
<p class="tx">If you need to match an actual question mark character, escape it with <span class="thesansmonocd_w5regular_">\?</span>.</p>
</section>
<section type="division" aria-labelledby="sec15">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-867" aria-label="197"></span>
<h4 class="h1" id="calibre_link-1640"><span id="calibre_link-204"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching Zero or More Qualifiers</span></h4>
<p class="tni">The <span class="thesansmonocd_w5regular_">*</span> (called the <i class="calibre5">star</i> or <i class="calibre5">asterisk</i>) means “match zero or more.” In other words, the qualifier that precedes the star can occur any number of times in the text. It can be completely absent or repeated over and over again. Take a look at the following example:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile('Eggs(and spam)*')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.search('Eggs')</b>
&lt;re.Match object; span=(0, 4), match='Eggs'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('Eggs and spam')</b>
&lt;re.Match object; span=(0, 13), match='Eggs and spam'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('Eggs and spam and spam')</b>
&lt;re.Match object; span=(0, 22), match='Eggs and spam and spam'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('Eggs and spam and spam and spam')</b>
&lt;re.Match object; span=(0, 31), match='Eggs and spam and spam and spam'&gt;
</code></pre>
<p class="tx">While the <span class="thesansmonocd_w5regular_">'Eggs'</span> part of the string must appear once, there can be any number of <span class="thesansmonocd_w5regular_">' and spam'</span> following it, including zero instances.</p>
<p class="tx">If you need to match an actual star character, prefix the star in the regular expression with a backslash, <span class="thesansmonocd_w5regular_">\*</span>.</p>
</section>
<section type="division" aria-labelledby="sec16">
<h4 class="h1" id="calibre_link-1641"><span id="calibre_link-205"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching One or More Qualifiers</span></h4>
<p class="tni">While <span class="thesansmonocd_w5regular_">*</span> means “match zero or more,” the <span class="thesansmonocd_w5regular_">+</span> (or <i class="calibre5">plus</i>) means “match one or more.” Unlike the star, which does not require its qualifier to appear in the matched string, the plus requires the qualifier preceding it to appear <i class="calibre5">at least once</i>. It is not optional. Enter the following into the interactive shell, and compare it with the star regexes in the previous section:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">pattern = re.compile('Eggs(and spam)+')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.search('Eggs and spam')</b>
&lt;re.Match object; span=(0, 13), match='Eggs and spam'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('Eggs and spam and spam')</b>
&lt;re.Match object; span=(0, 22), match='Eggs and spam and spam'&gt;
&gt;&gt;&gt; <b class="calibre10">pattern.search('Eggs and spam and spam and spam')</b>
&lt;re.Match object; span=(0, 31), match='Eggs and spam and spam and spam'&gt;
</code></pre>
<p class="tx">The regex <span class="thesansmonocd_w5regular_">'Eggs(and spam)+'</span> will not match the string <span class="thesansmonocd_w5regular_">'Eggs'</span>, because the plus sign requires at least one <span class="thesansmonocd_w5regular_">' and spam'</span>.</p>
<p class="tx">You’ll often use parentheses in your regex strings to group together qualifiers so that a quantifier can apply to the entire group. For example, you could match any combination of dots and dashes of Morse code with <span class="thesansmonocd_w5regular_">r'(\.|\-)+'</span> (though this expression would also match invalid Morse code combinations).</p>
<p class="tx">If you need to match an actual plus sign character, prefix the plus sign with a backslash to escape it: <span class="thesansmonocd_w5regular_">\+</span>.</p>
</section>
<section type="division" aria-labelledby="sec17">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-851" aria-label="198"></span>
<h4 class="h1" id="calibre_link-1642"><span id="calibre_link-206"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching a Specific Number of Qualifiers</span></h4>
<p class="tni">If you have a group that you want to repeat a specific number of times, follow the group in your regex with a number in curly brackets. For example, the regex <span class="thesansmonocd_w5regular_">(Ha){3}</span> will match the string <span class="thesansmonocd_w5regular_">'HaHaHa'</span> but not <span class="thesansmonocd_w5regular_">'HaHa'</span>, since the latter has only two repeats of the <span class="thesansmonocd_w5regular_">(Ha)</span> group.</p>
<p class="tx">Instead of one number, you can specify a range by writing a minimum, a comma, and a maximum in between the curly brackets. For example, the regex <span class="thesansmonocd_w5regular_">(Ha){3,5}</span> will match <span class="thesansmonocd_w5regular_">'HaHaHa'</span>, <span class="thesansmonocd_w5regular_">'HaHaHaHa'</span>, and <span class="thesansmonocd_w5regular_">'HaHaHaHaHa'</span>.</p>
<p class="tx">You can also leave out the first or second number in the curly brackets to keep the minimum or maximum unbounded. For example, <span class="thesansmonocd_w5regular_">(Ha){3,}</span> will match three or more instances of the <span class="thesansmonocd_w5regular_">(Ha)</span> group, while <span class="thesansmonocd_w5regular_">(Ha){,5}</span> will match zero to five instances. Curly brackets can help make your regular expressions shorter. These two regular expressions match identical patterns:</p>
<pre class="pre"><code class="calibre9">(Ha){3}
HaHaHa
</code></pre>
<p class="tx">So do these two regular expressions:</p>
<pre class="pre"><code class="calibre9">(Ha){3,5}
(HaHaHa)|(HaHaHaHa)|(HaHaHaHaHa)
</code></pre>
<p class="tx">Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">haRegex = re.compile(r'(Ha){3}')</b>
&gt;&gt;&gt; <b class="calibre10">match1 = haRegex.search('HaHaHa')</b>
&gt;&gt;&gt; <b class="calibre10">match1.group()</b>
'HaHaHa'

&gt;&gt;&gt; <b class="calibre10">match = haRegex.search('HaHa')</b>
&gt;&gt;&gt; <b class="calibre10">match == None</b>
True
</code></pre>
<p class="tx">Here, <span class="thesansmonocd_w5regular_">(Ha){3}</span> matches <span class="thesansmonocd_w5regular_">'HaHaHa'</span> but not <span class="thesansmonocd_w5regular_">'Ha'</span>. Because it doesn’t match <span class="thesansmonocd_w5regular_">'HaHa'</span>, <span class="thesansmonocd_w5regular_">search()</span> returns <span class="thesansmonocd_w5regular_">None</span>.</p>
<p class="tx">The syntax of the curly bracket quantifier is similar to Python’s slice syntax (such as <span class="thesansmonocd_w5regular_">'Hello, world!'[3:5]</span>, which evaluates to <span class="thesansmonocd_w5regular_">'lo'</span>). But there are key differences. In the regex quantifier, the two numbers are separated by a comma and not a colon. Also, the second number in the quantifier is inclusive: <span class="thesansmonocd_w5regular_">'(Ha){3,5}'</span> matches up to <i class="calibre5">and including</i> five instances of the <span class="thesansmonocd_w5regular_">'(Ha)'</span> qualifier.</p>
</section>
</section>
<section type="division" aria-labelledby="sec18">
<h3 class="h" id="calibre_link-1643"><span id="calibre_link-207"></span><span class="sans_futura_std_bold_b_">Greedy and Non-greedy Matching</span></h3>
<p class="tni">Because <span class="thesansmonocd_w5regular_">(Ha){3,5}</span> can match three, four, or five instances of <span class="thesansmonocd_w5regular_">Ha</span> in the string <span class="thesansmonocd_w5regular_">'HaHaHaHaHa'</span>, you may wonder why the <span class="thesansmonocd_w5regular_">Match</span> object’s call to <span class="thesansmonocd_w5regular_">group()</span> in the previous curly bracket example returns <span class="thesansmonocd_w5regular_">'HaHaHaHaHa'</span> instead of the shorter <span role="doc-pagebreak" type="pagebreak" id="calibre_link-858" aria-label="199"></span>possibilities. After all, <span class="thesansmonocd_w5regular_">'HaHaHa'</span> and <span class="thesansmonocd_w5regular_">'HaHaHaHa'</span> are also valid matches of the regular expression <span class="thesansmonocd_w5regular_">(Ha){3,5}</span>.</p>
<p class="tx">Python’s regular expressions are <i class="calibre5">greedy</i> by default, which means that in ambiguous situations, they will match the longest string possible. The <i class="calibre5">non-greedy</i> (also called <i class="calibre5">lazy</i>) version of the curly brackets, which matches the shortest string possible, must follow the closing curly bracket with a question mark.</p>
<p class="tx">Enter the following into the interactive shell, and notice the difference between the greedy and non-greedy forms of the curly brackets searching the same string:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">greedy_pattern = re.compile(r'(Ha){3,5}')</b>
&gt;&gt;&gt; <b class="calibre10">match1 = greedy_pattern.search('HaHaHaHaHa')</b>
&gt;&gt;&gt; <b class="calibre10">match1.group()</b>
'HaHaHaHaHa'

&gt;&gt;&gt; <b class="calibre10">lazy_pattern = re.compile(r'(Ha){3,5}?')</b>
&gt;&gt;&gt; <b class="calibre10">match2 = lazy_pattern.search('HaHaHaHaHa')</b>
&gt;&gt;&gt; <b class="calibre10">match2.group()</b>
'HaHaHa'
</code></pre>
<p class="tx">Note that the question mark can have two meanings in regular expressions: declaring a lazy match or declaring an optional qualifier. These meanings are entirely unrelated.</p>
<p class="tx">It’s worth pointing out that, technically, you could get by without using the optional <span class="thesansmonocd_w5regular_">?</span> quantifier, or even the <span class="thesansmonocd_w5regular_">*</span> and <span class="thesansmonocd_w5regular_">+</span> quantifiers:</p>
<ul class="ul">
<li class="bl">The <span class="thesansmonocd_w5regular_">?</span> quantifier is the same as <span class="thesansmonocd_w5regular_">{0,1}</span>.</li>
<li class="bl">The <span class="thesansmonocd_w5regular_">*</span> quantifier is the same as <span class="thesansmonocd_w5regular_">{0,}</span>.</li>
<li class="bl">The <span class="thesansmonocd_w5regular_">+</span> quantifier is the same as <span class="thesansmonocd_w5regular_">{1,}</span>.</li>
</ul>
<p class="tx">However, the <span class="thesansmonocd_w5regular_">?</span>, <span class="thesansmonocd_w5regular_">*</span>, and <span class="thesansmonocd_w5regular_">+</span> quantifiers are common shorthand.</p>
<section type="division" aria-labelledby="sec19">
<h4 class="h1" id="calibre_link-1644"><span id="calibre_link-208"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching Everything</span></h4>
<p class="tni">Sometimes you may want to match everything and anything. For example, say you want to match the string <span class="thesansmonocd_w5regular_">'First Name:'</span>, followed by any and all text, followed by <span class="thesansmonocd_w5regular_">'Last Name:'</span> and any text once again. You can use the dot-star (<span class="thesansmonocd_w5regular_">.*</span>) to stand in for that “anything.” Remember that the dot character means “any single character except the newline,” and the star character means “zero or more of the preceding character.”</p>
<p class="tx">Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">name_pattern = re.compile(r'First Name: (.*) Last Name: (.*)')</b>
&gt;&gt;&gt; <b class="calibre10">name_match = name_pattern.search('First Name: Al Last Name: Sweigart')</b>
&gt;&gt;&gt; <b class="calibre10">name_match.group(1)</b>
'Al'
&gt;&gt;&gt; <b class="calibre10">name_match.group(2)</b>
'Sweigart'
</code></pre>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1117" aria-label="200"></span>The dot-star uses greedy mode: it will always try to match as much text as possible. To match any and all text in a non-greedy or lazy fashion, use the dot, star, and question mark (<span class="thesansmonocd_w5regular_">.*?</span>). As when it’s used with curly brackets, the question mark tells Python to match in a non-greedy way.</p>
<p class="tx">Enter the following into the interactive shell to see the difference between the greedy and non-greedy expressions:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">lazy_pattern = re.compile(r'&lt;.*?&gt;')</b>
&gt;&gt;&gt; <b class="calibre10">match1 = lazy_pattern.search('&lt;To serve man&gt; for dinner.&gt;')</b>
&gt;&gt;&gt; <b class="calibre10">match1.group()</b>
'&lt;To serve man&gt;'

&gt;&gt;&gt; <b class="calibre10">greedy_re = re.compile(r'&lt;.*&gt;')</b>
&gt;&gt;&gt; <b class="calibre10">match2 = greedy_re.search('&lt;To serve man&gt; for dinner.&gt;')</b>
&gt;&gt;&gt; <b class="calibre10">match2.group()</b>
'&lt;To serve man&gt; for dinner.&gt;'
</code></pre>
<p class="tx">Both regexes roughly translate to “Match an opening angle bracket, followed by anything, followed by a closing angle bracket.” But the string <span class="thesansmonocd_w5regular_">'&lt;To serve man&gt; for dinner.&gt;'</span> has two possible matches for the closing angle bracket. In the non-greedy version of the regex, Python matches the shortest possible string: <span class="thesansmonocd_w5regular_">'&lt;To serve man&gt;'</span>. In the greedy version, Python matches the longest possible string: <span class="thesansmonocd_w5regular_">'&lt;To serve man&gt; for dinner.&gt;'</span>.</p>
</section>
<section type="division" aria-labelledby="sec20">
<h4 class="h1" id="calibre_link-1645"><span id="calibre_link-209"></span><span class="sans_futura_std_heavy_oblique_bi_">Matching Newline Characters</span></h4>
<p class="tni">The dot in <span class="thesansmonocd_w5regular_">.*</span> will match everything except a newline. By passing <span class="thesansmonocd_w5regular_">re.DOTALL</span> as the second argument to <span class="thesansmonocd_w5regular_">re.compile()</span>, you can make the dot character match <i class="calibre5">all</i> characters, including the newline character.</p>
<p class="tx">Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">no_newline_re = re.compile('.*')</b>
&gt;&gt;&gt;<b class="calibre10"> no_newline_re.search('Serve the public trust.\nProtect the innocent. </b>
<b class="calibre10">\nUphold the law.').group()</b>
'Serve the public trust.'

&gt;&gt;&gt; <b class="calibre10">newline_re = re.compile('.*', re.DOTALL)</b>
&gt;&gt;&gt; <b class="calibre10">newline_re.search('Serve the public trust.\nProtect the innocent. </b>
<b class="calibre10">\nUphold the law.').group()</b>
'Serve the public trust.\nProtect the innocent.\nUphold the law.'
</code></pre>
<p class="tx">The regex <span class="thesansmonocd_w5regular_">no_newline_re</span>, which did not have <span class="thesansmonocd_w5regular_">re.DOTALL</span> passed to the <span class="thesansmonocd_w5regular_">re.compile()</span> call that created it, will match everything only up to the first newline character, whereas <span class="thesansmonocd_w5regular_">newline_re</span>, which <i class="calibre5">did</i> have <span class="thesansmonocd_w5regular_">re.DOTALL</span> passed to <span class="thesansmonocd_w5regular_">re.compile()</span>, matches everything. This is why the <span class="thesansmonocd_w5regular_">newline_re.search()</span> call matches the full string, including its newline characters.</p>
</section>
</section>
<section type="division" aria-labelledby="sec21">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-852" aria-label="201"></span>
<h3 class="h" id="calibre_link-1646"><span id="calibre_link-210"></span><span class="sans_futura_std_bold_b_">Matching at the Start and End of a String</span></h3>
<p class="tni">You can use the caret symbol (<span class="thesansmonocd_w5regular_">^</span>) at the start of a regex to indicate that a match must occur at the <i class="calibre5">beginning</i> of the searched text. Likewise, you can put a dollar sign (<span class="thesansmonocd_w5regular_">$</span>) at the end of the regex to indicate that the string must <i class="calibre5">end</i> with this regex pattern. And you can use the <span class="thesansmonocd_w5regular_">^</span> and <span class="thesansmonocd_w5regular_">$</span> together to indicate that the entire string must match the regex&mdash;that is, it’s not enough for a match to be made on some subset of the string.</p>
<p class="tx">For example, the <span class="thesansmonocd_w5regular_">r'^Hello'</span> regular expression string matches strings that begin with <span class="thesansmonocd_w5regular_">'Hello'</span>. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">begins_with_hello = re.compile(r'^Hello')</b>
&gt;&gt;&gt; <b class="calibre10">begins_with_hello.search('Hello, world!')</b>
&lt;re.Match object; span=(0, 5), match='Hello'&gt;
&gt;&gt;&gt; <b class="calibre10">begins_with_hello.search('He said "Hello."') == None</b>
True
</code></pre>
<p class="tx">The <span class="thesansmonocd_w5regular_">r'\d$'</span> regular expression string matches strings that end with a numeric character between 0 and 9. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">ends_with_number = re.compile(r'\d$')</b>
&gt;&gt;&gt; <b class="calibre10">ends_with_number.search('Your number is 42')</b>
&lt;re.Match object; span=(16, 17), match='2'&gt;
&gt;&gt;&gt; <b class="calibre10">ends_with_number.search('Your number is forty two.') == None</b>
True
</code></pre>
<p class="tx">The <span class="thesansmonocd_w5regular_">r'^\d+$'</span> regular expression string matches strings that both begin and end with one or more numeric characters. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">whole_string_is_num = re.compile(r'^\d+$')</b>
&gt;&gt;&gt; <b class="calibre10">whole_string_is_num.search('1234567890')</b>
&lt;re.Match object; span=(0, 10), match='1234567890'&gt;
&gt;&gt;&gt; <b class="calibre10">whole_string_is_num.search('12345xyz67890') == None</b>
True
</code></pre>
<p class="tx">The last two <span class="thesansmonocd_w5regular_">search()</span> calls in the previous interactive shell example demonstrate how the entire string must match the regex if <span class="thesansmonocd_w5regular_">^</span> and <span class="thesansmonocd_w5regular_">$</span> are used. (I always confuse the meanings of these two symbols, so I use the mnemonic “carrots cost dollars” to remind myself that the caret comes first and the dollar sign comes last.)</p>
<p class="tx">You can also use <span class="thesansmonocd_w5regular_">\b</span> to make a regex pattern match only on a <i class="calibre5">word boundary</i>: the start of a word, end of a word, or both the start and end of a word. In this case, a “word” is a sequence of letters separated by non-letter <span role="doc-pagebreak" type="pagebreak" id="calibre_link-1647" aria-label="202"></span>characters. For example, <span class="thesansmonocd_w5regular_">r'\bcat.*?\b'</span> matches a word that begins with <span class="thesansmonocd_w5regular_">'cat'</span> followed by any other characters up to the next word boundary:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'\bcat.*?\b')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.findall('The cat found a catapult catalog in the catacombs.')</b>
['cat', 'catapult', 'catalog', 'catacombs']
</code></pre>
<p class="tx">The <span class="thesansmonocd_w5regular_">\B</span> syntax matches anything that is not a word boundary:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'\Bcat\B')</b>
&gt;&gt;&gt; <b class="calibre10">pattern.findall('certificate')</b>  # Match
['cat']
&gt;&gt;&gt; <b class="calibre10">pattern.findall('catastrophe')</b>  # No match
[]
</code></pre>
<p class="tx">It is useful for finding matches in the middle of a word.</p>
<aside class="box" aria-label="box-12">
<p class="bt" id="calibre_link-1648"><span class="sans_futura_std_bold_b_">A REVIEW OF REGEX SYMBOLS</span></p>
<p class="btni"><span class="sans_futura_std_book_">This chapter has covered a lot of notation so far, so here’s a quick review of what you’ve learned about basic regular expression syntax:</span></p>
<ul class="ul">
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">?</span> <span class="sans_futura_std_book_">matches zero or one instance of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">*</span> <span class="sans_futura_std_book_">matches zero or more instances of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">+</span> <span class="sans_futura_std_book_">matches one or more instances of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">{n}</span> <span class="sans_futura_std_book_">matches exactly</span> <span class="sans_futura_std_book_oblique_i_">n</span> <span class="sans_futura_std_book_">instances of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">{n,}</span> <span class="sans_futura_std_book_">matches</span> <span class="sans_futura_std_book_oblique_i_">n</span> <span class="sans_futura_std_book_">or more instances of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">{,m}</span> <span class="sans_futura_std_book_">matches 0 to</span> <span class="sans_futura_std_book_oblique_i_">m</span> <span class="sans_futura_std_book_">instances of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">{n,m}</span> <span class="sans_futura_std_book_">matches at least</span> <span class="sans_futura_std_book_oblique_i_">n</span> <span class="sans_futura_std_book_">and at most</span> <span class="sans_futura_std_book_oblique_i_">m</span> <span class="sans_futura_std_book_">instances of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">{n,m}?</span> <span class="sans_futura_std_book_">or</span> <span class="thesansmonocd_w5regular_">*?</span> <span class="sans_futura_std_book_">or</span> <span class="thesansmonocd_w5regular_">+?</span> <span class="sans_futura_std_book_">performs a non-greedy match of the preceding qualifier.</span></li>
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">^spam</span> <span class="sans_futura_std_book_">means the string must begin with</span> <span class="sans_futura_std_book_oblique_i_">spam</span><span class="sans_futura_std_book_">.</span></li>
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">spam$</span> <span class="sans_futura_std_book_">means the string must end with</span> <span class="sans_futura_std_book_oblique_i_">spam</span><span class="sans_futura_std_book_">.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">.</span> <span class="sans_futura_std_book_">matches any character, except newline characters.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">\d</span><span class="sans_futura_std_book_">,</span> <span class="thesansmonocd_w5regular_">\w</span><span class="sans_futura_std_book_">, and</span> <span class="thesansmonocd_w5regular_">\s</span> <span class="sans_futura_std_book_">match a digit, word, or space character, respectively.</span></li>
<li class="boxlistbullet"><span class="sans_futura_std_book_">The</span> <span class="thesansmonocd_w5regular_">\D</span><span class="sans_futura_std_book_">,</span> <span class="thesansmonocd_w5regular_">\W</span><span class="sans_futura_std_book_">, and</span> <span class="thesansmonocd_w5regular_">\S</span> <span class="sans_futura_std_book_">match anything except a digit, word, or space character, respectively.</span> <span class="thesansmonocd_w5regular_">[abc]</span> <span class="sans_futura_std_book_">matches any character between the square brackets (such as</span> <span class="sans_futura_std_book_oblique_i_">a</span><span class="sans_futura_std_book_">,</span> <span class="sans_futura_std_book_oblique_i_">b</span><span class="sans_futura_std_book_">, or</span> <span class="sans_futura_std_book_oblique_i_">c</span><span class="sans_futura_std_book_">).</span></li>
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">[^abc]</span> <span class="sans_futura_std_book_">matches any character that isn’t between the square brackets.</span></li>
<li class="boxlistbullet"><span class="thesansmonocd_w5regular_">(Hello)</span> <span class="sans_futura_std_book_">groups</span> <span class="thesansmonocd_w5regular_">'Hello'</span> <span class="sans_futura_std_book_">together as a single qualifier.</span></li>
</ul>
</aside>
</section>
<section type="division" aria-labelledby="sec22">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-947" aria-label="203"></span>
<h3 class="h" id="calibre_link-1649"><span id="calibre_link-211"></span><span class="sans_futura_std_bold_b_">Case-Insensitive Matching</span></h3>
<p class="tni">Normally, regular expressions match text with the exact casing you specify. For example, the following regexes match completely different strings:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern1 = re.compile('RoboCop')</b>
&gt;&gt;&gt; <b class="calibre10">pattern2 = re.compile('ROBOCOP')</b>
&gt;&gt;&gt; <b class="calibre10">pattern3 = re.compile('robOcop')</b>
&gt;&gt;&gt; <b class="calibre10">pattern4 = re.compile('RobocOp')</b>
</code></pre>
<p class="tx">But sometimes you care only about matching the letters, and aren’t worried about whether they’re uppercase or lowercase. To make your regex case-insensitive, you can pass <span class="thesansmonocd_w5regular_">re.IGNORECASE</span> or <span class="thesansmonocd_w5regular_">re.I</span> as a second argument to <span class="thesansmonocd_w5regular_">re.compile()</span>. Enter the following into the interactive shell:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(r'robocop', re.I)</b>
&gt;&gt;&gt; <b class="calibre10">pattern.search('RoboCop is part man, part machine, all cop.').group()</b>
'RoboCop'

&gt;&gt;&gt; <b class="calibre10">pattern.search('ROBOCOP protects the innocent.').group()</b>
'ROBOCOP'

&gt;&gt;&gt; <b class="calibre10">pattern.search('Have you seen robocop?').group()</b>
'robocop'
</code></pre>
<p class="tx">The regular expression now matches strings with any casing.</p>
</section>
<section type="division" aria-labelledby="sec23">
<h3 class="h" id="calibre_link-1650"><span id="calibre_link-212"></span><span class="sans_futura_std_bold_b_">Substituting Strings</span></h3>
<p class="tni">Regular expressions don’t merely find text patterns; they can also substitute new text in place of those patterns. The <span class="thesansmonocd_w5regular_">sub()</span> method for <span class="thesansmonocd_w5regular_">Pattern</span> objects accepts two arguments. The first is a string that should replace any matches. The second is the string of the regular expression. The <span class="thesansmonocd_w5regular_">sub()</span> method returns a string with the substitutions applied.</p>
<p class="tx">For example, enter the following into the interactive shell to replace secret agents’ names with <span class="thesansmonocd_w5regular_">CENSORED</span>:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">agent_pattern = re.compile(r'Agent \w+')</b>
&gt;&gt;&gt; <b class="calibre10">agent_pattern.sub('CENSORED', 'Agent Alice contacted Agent Bob.')</b>
'CENSORED contacted CENSORED.'
</code></pre>
<p class="tx">Sometimes you may need to use the matched text itself as part of the substitution. In the first argument to <span class="thesansmonocd_w5regular_">sub()</span>, you can include <span class="thesansmonocd_w5regular_">\1</span>, <span class="thesansmonocd_w5regular_">\2</span>, <span class="thesansmonocd_w5regular_">\3</span>, and so on, to mean “Enter the text of group <span class="thesansmonocd_w5regular_">1</span>, <span class="thesansmonocd_w5regular_">2</span>, <span class="thesansmonocd_w5regular_">3</span>, and so on, in the substitution.” This syntax is called a <i class="calibre5">back reference</i>.</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-861" aria-label="204"></span>For example, say you want to censor the names of the secret agents by showing just the first letters of their names. To do this, you could use the regex <span class="thesansmonocd_w5regular_">Agent (\w)\w*</span> and pass <span class="thesansmonocd_w5regular_">r'\1****'</span> as the first argument to <span class="thesansmonocd_w5regular_">sub()</span>:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">agent_pattern = re.compile(r'Agent (\w)\w*')</b>
&gt;&gt;&gt; <b class="calibre10">agent_pattern.sub(r'\1****', 'Agent Alice contacted Agent Bob.')</b>
'A**** contacted B****.'
</code></pre>
<p class="tx">The <span class="thesansmonocd_w5regular_">\1</span> in the regular expression string is replaced by whatever text was matched by group <span class="thesansmonocd_w5regular_">1</span>&mdash;that is, the <span class="thesansmonocd_w5regular_">(\w)</span> group of the regular expression.</p>
</section>
<section type="division" aria-labelledby="sec24">
<h3 class="h" id="calibre_link-1651"><span id="calibre_link-213"></span><span class="sans_futura_std_bold_b_">Managing Complex Regexes with Verbose Mode</span></h3>
<p class="tni">Regular expressions are fine if the text pattern you need to match is simple. But matching complicated text patterns might require long, convoluted regular expressions. You can mitigate this complexity by telling the <span class="thesansmonocd_w5regular_">re.compile()</span> function to ignore whitespace and comments inside the regular expression string. Enable this “verbose mode” by passing the variable <span class="thesansmonocd_w5regular_">re.VERBOSE</span> as the second argument to <span class="thesansmonocd_w5regular_">re.compile()</span>.</p>
<p class="tx">Now, instead of a hard-to-read regular expression like this</p>
<pre class="pre"><code class="calibre9">pattern = re.compile(r'((\d{3}|\(\d{3}\))?(\s|-|\.)?\d{3}(\s|-
|\.)\d{4}(\s*(ext|x|ext\.)\s*\d{2,5})?)')
</code></pre>
<p class="tni">you can spread the regular expression over multiple lines and use comments to label its components, like this:</p>
<pre class="pre"><code class="calibre9">pattern = re.compile(r'''(
    (\d{3}|\(\d{3}\))?  # Area code
    (\s|-|\.)?  # Separator
    \d{3}  # First three digits
    (\s|-|\.)  # Separator
    \d{4}  # Last four digits
    (\s*(ext|x|ext\.)\s*\d{2,5})?  # Extension
    )''', re.VERBOSE)
</code></pre>
<p class="tx">Note how the previous example uses the triple-quote syntax (<span class="thesansmonocd_w5regular_">'''</span>) to create a multiline string so that you can spread the regular expression definition over many lines, making it much more legible.</p>
<p class="tx">The comment rules inside the regular expression string are the same as for regular Python code: the <span class="thesansmonocd_w5regular_">#</span> symbol and everything after it until the end of the line are ignored. Also, the extra spaces inside the multiline string for the regular expression are not considered part of the text pattern to be matched. This lets you organize the regular expression so that it’s easier to read.</p>
<p class="tx">While verbose mode makes your regex strings more readable, I advise you to instead use the Humre module, covered later in this chapter, to improve the readability of your regular expressions.</p>
</section>
<section type="division" aria-labelledby="sec25">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-864" aria-label="205"></span>
<h3 class="h" id="calibre_link-1652"><span id="calibre_link-214"></span><span class="sans_futura_std_bold_b_">Combining re.IGNORECASE, re.DOTALL, and re.VERBOSE</span></h3>
<p class="tni">What if you want to use <span class="thesansmonocd_w5regular_">re.VERBOSE</span> to write comments in your regular expression, but also want to use <span class="thesansmonocd_w5regular_">re.IGNORECASE</span> to ignore capitalization? Unfortunately, the <span class="thesansmonocd_w5regular_">re.compile()</span> function takes only a single value as its second argument.</p>
<p class="tx">You can get around this limitation by combining the <span class="thesansmonocd_w5regular_">re.IGNORECASE</span>, <span class="thesansmonocd_w5regular_">re.DOTALL</span>, and <span class="thesansmonocd_w5regular_">re.VERBOSE</span> variables using the pipe character (<span class="thesansmonocd_w5regular_">|</span>), which in this context is known as the <i class="calibre5">bitwise or</i> operator. For example, if you want a regular expression that is case-insensitive <i class="calibre5">and</i> includes newlines to match the dot character, you would form your <span class="thesansmonocd_w5regular_">re.compile()</span> call like this:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">some_regex = re.compile('foo', re.IGNORECASE | re.DOTALL)</b></code></pre>
<p class="tx">Including all three options in the second argument looks like this:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">some_regex = re.compile('foo', re.IGNORECASE | re.DOTALL | re.VERBOSE)</b></code></pre>
<p class="tx">This syntax is a little old-fashioned and originates from early versions of Python. The details of the bitwise operators are beyond the scope of this book, but check out the resources at <i class="calibre5"><a href="https://nostarch.com/automate-boring-stuff-python-3rd-edition" class="calibre1">https://<wbr></wbr>nostarch<wbr></wbr>.com<wbr></wbr>/automate<wbr></wbr>-boring<wbr></wbr>-stuff<wbr></wbr>-python<wbr></wbr>-3rd<wbr></wbr>-edition </a></i>for more information. You can also pass other options for the second argument; they’re uncommon, but you can read more about them in the resources too.</p>
<p class="ph"><span id="calibre_link-215"></span><span class="sans_futura_std_heavy_b_">Project 3: Extract Contact Information from Large Documents</span></p>
<p class="tni">Say you’ve been given the boring task of finding every phone number and email address in a long web page or document. If you manually scroll through the page, you might end up searching for a long time. But if you had a program that could search the text in your clipboard for phone numbers and email addresses, you could simply press <small class="calibre4">CTRL</small>-A to select all the text, press <small class="calibre4">CTRL</small>-C to copy it to the clipboard, and then run your program. It could replace the text on the clipboard with just the phone numbers and email addresses it finds.</p>
<p class="tx">Whenever you’re tackling a new project, it can be tempting to dive right into writing code. But more often than not, it’s best to take a step back and consider the bigger picture. I recommend first drawing up a high-level plan for what your program needs to do. Don’t think about the actual code yet; you can worry about that later. Right now, stick to broad strokes.</p>
<p class="tx">For example, your phone number and email address extractor will need to do the following:</p>
<ul class="ul">
<li class="bl">Get the text from the clipboard.</li>
<li class="bl">Find all phone numbers and email addresses in the text.</li>
<li class="bl">Paste them onto the clipboard.</li>
</ul>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1653" aria-label="206"></span>Now you can start thinking about how this might work in code. The code will need to do the following:</p>
<ul class="ul">
<li class="bl">Use the <span class="thesansmonocd_w5regular_">pyperclip</span> module to copy and paste strings.</li>
<li class="bl">Create two regexes, one for matching phone numbers and one for matching email addresses.</li>
<li class="bl">Find all matches (not just the first match) of both regexes.</li>
<li class="bl">Neatly format the matched strings into a single string to paste.</li>
<li class="bl">Display some kind of message if no matches were found in the text.</li>
</ul>
<p class="tx">This list is like a road map for the project. As you write the code, you can focus on each of these steps separately, and each step should seem fairly manageable. They’re also expressed in terms of things you already know how to do in Python.</p>
<section type="division" aria-labelledby="sec26">
<h4 class="h1" id="calibre_link-1654"><span id="calibre_link-216"></span><span class="sans_futura_std_heavy_oblique_bi_">Step 1: Create a Regex for Phone Numbers</span></h4>
<p class="tni">First, you have to create a regular expression to search for phone numbers. Create a new file, enter the following, and save it as <i class="calibre5">phoneAndEmail.py</i>:</p>
<pre class="pre"><code class="calibre9">import pyperclip, re

phone_re = re.compile(r'''(
    (\d{3}|\(\d{3}\))?  # Area code
    (\s|-|\.)?  # Separator
    (\d{3})  # First three digits
    (\s|-|\.)  # Separator
    (\d{4})  # Last four digits
    (\s*(ext|x|ext\.)\s*(\d{2,5}))?  # Extension
    )''', re.VERBOSE)

# TODO: Create email regex.

# TODO: Find matches in clipboard text.

# TODO: Copy results to the clipboard.
</code></pre>
<p class="tx">The <span class="thesansmonocd_w5regular_">TODO</span> comments are just a skeleton for the program. They’ll be replaced as you write the actual code.</p>
<p class="tx">The phone number begins with an <i class="calibre5">optional</i> area code, so we follow the area code group with a question mark. Since the area code can be just three digits (that is, <span class="thesansmonocd_w5regular_">\d{3}</span>) <i class="calibre5">or</i> three digits within parentheses (that is, <span class="thesansmonocd_w5regular_">\(\d{3}\)</span>), you should have a pipe joining those parts. You can add the regex comment <span class="thesansmonocd_w5regular_"># Area code</span> to this part of the multiline string to help you remember what <span class="thesansmonocd_w5regular_">(\d{3}|\(\d{3}\))?</span> is supposed to match.</p>
<p class="tx">The phone number separator character can be an <i class="calibre5">optional</i> space (<span class="thesansmonocd_w5regular_">\s</span>), hyphen (<span class="thesansmonocd_w5regular_">-</span>), or period (<span class="thesansmonocd_w5regular_">.</span>), so we should also join these parts using pipes. The next few parts of the regular expression are straightforward: three digits, followed by another separator, followed by four digits. The last part is an <span role="doc-pagebreak" type="pagebreak" id="calibre_link-1164" aria-label="207"></span>optional extension made up of any number of spaces followed by <span class="thesansmonocd_w5regular_">ext</span>, <span class="thesansmonocd_w5regular_">x</span>, or <span class="thesansmonocd_w5regular_">ext.</span>, followed by two to five digits.</p>
<blockquote class="calibre17">
<p class="note"><span class="sans_dogma_ot_bold_b_1">NOTE</span></p>
</blockquote>
<p class="note-txt"><i class="calibre5">It’s easy to get mixed up when writing regular expressions that contain groups with parentheses <span class="sans_thesansmonocd_w5regular_italic_">()</span> and escaped parentheses <span class="sans_thesansmonocd_w5regular_italic_">\(\)</span>. Remember to double-check that you’re using the correct syntax if you get a “missing), unterminated subpattern” error message.</i></p>
</section>
<section type="division" aria-labelledby="sec27">
<h4 class="h1" id="calibre_link-1655"><span id="calibre_link-217"></span><span class="sans_futura_std_heavy_oblique_bi_">Step 2: Create a Regex for Email Addresses</span></h4>
<p class="tni">You will also need a regular expression that can match email addresses. Make your program look like the following:</p>
<pre class="pre"><code class="calibre9">import pyperclip, re

phone_re = re.compile(r'''(
--<var class="calibre20">snip</var>--

<b class="calibre10"># Create email regex.</b>
<b class="calibre10">email_re = re.compile(r'''(</b>
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation1">❶</span><b class="calibre10"> [a-zA-Z0-9._%+-]+  </b># Username
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation2">❷</span><b class="calibre10"> @  # @ symbol</b>
<b class="calibre10">  </b><span class="code_codeannotation" aria-label="annotation3">❸</span><b class="calibre10"> [a-zA-Z0-9.-]+  </b># Domain name
<b class="calibre10">    (\.[a-zA-Z]{2,4})  </b># Dot-something
<b class="calibre10">    )''', re.VERBOSE)</b>

# TODO: Find matches in clipboard text.

# TODO: Copy results to the clipboard.
</code></pre>
<p class="tx">The username part of the email address <span class="codeannotation" aria-label="annotation1">❶</span> consists of one or more characters that can be any of the following: lowercase and uppercase letters, numbers, a dot, an underscore, a percent sign, a plus sign, or a hyphen. You can put all of these into a character class: <span class="thesansmonocd_w5regular_">[a-zA-Z0-9._%+-]</span>.</p>
<p class="tx">The domain and username are separated by an <span class="thesansmonocd_w5regular_">@</span> symbol <span class="codeannotation" aria-label="annotation2">❷</span>. The domain name <span class="codeannotation" aria-label="annotation3">❸</span> has a slightly less permissive character class, with only letters, numbers, periods, and hyphens: <span class="thesansmonocd_w5regular_">[a-zA-Z0-9.-]</span>. Last is the “dot-com” part (technically known as the <i class="calibre5">top-level domain</i>), which can really be dot-anything.</p>
<p class="tx">The format for email addresses has a lot of weird rules. This regular expression won’t match every possible valid email address, but it will match almost any typical email address you’ll encounter.</p>
</section>
<section type="division" aria-labelledby="sec28">
<h4 class="h1" id="calibre_link-1656"><span id="calibre_link-218"></span><span class="sans_futura_std_heavy_oblique_bi_">Step 3: Find All Matches in the Clipboard Text</span></h4>
<p class="tni">Now that you’ve specified the regular expressions for phone numbers and email addresses, you can let Python’s <span class="thesansmonocd_w5regular_">re</span> module do the hard work of finding all the matches on the clipboard. The <span class="thesansmonocd_w5regular_">pyperclip.paste()</span> function will get a string value of the text on the clipboard, and the <span class="thesansmonocd_w5regular_">findall()</span> regex method will return a list of tuples.</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1657" aria-label="208"></span>Make your program look like the following:</p>
<pre class="pre"><code class="calibre9">import pyperclip, re

phone_re = re.compile(r'''(
--<var class="calibre20">snip</var>--

<b class="calibre10"># Find matches in clipboard text.</b>
<b class="calibre10">text = str(pyperclip.paste())</b>

<span class="codeannotated_codeannotation" aria-label="annotation1">❶</span><b class="calibre10"> matches = []</b>
<span class="codeannotated_codeannotation" aria-label="annotation2">❷</span><b class="calibre10"> for groups in phone_re.findall(text):</b>
<b class="calibre10">    phone_num = '-'.join([groups[1], groups[3], groups[5]])</b>
<b class="calibre10">    if groups[6] != '':</b>
<b class="calibre10">        phone_num += ' x' + groups[6]</b>
<b class="calibre10">    matches.append(phone_num)</b>
<span class="codeannotated_codeannotation" aria-label="annotation3">❸</span><b class="calibre10"> for groups in email_re.findall(text):</b>
<b class="calibre10">    matches.append(groups[0])</b>

# TODO: Copy results to the clipboard.
</code></pre>
<p class="tx">There is one tuple for each match, and each tuple contains strings for each group in the regular expression. Remember that group <span class="thesansmonocd_w5regular_">0</span> matches the entire regular expression, so the group at index <span class="thesansmonocd_w5regular_">0</span> of the tuple is the one you are interested in.</p>
<p class="tx">As you can see at <span class="codeannotation" aria-label="annotation1">❶</span>, you’ll store the matches in a list variable named <span class="thesansmonocd_w5regular_">matches</span>. It starts off as an empty list and a couple of <span class="thesansmonocd_w5regular_">for</span> loops. For the email addresses, you append group <span class="thesansmonocd_w5regular_">0</span> of each match <span class="codeannotation" aria-label="annotation3">❸</span>. For the matched phone numbers, you don’t want to just append group <span class="thesansmonocd_w5regular_">0</span>. While the program <i class="calibre5">detects</i> phone numbers in several formats, you want the phone number appended to be in a single, standard format. The <span class="thesansmonocd_w5regular_">phone_num</span> variable contains a string built from groups <span class="thesansmonocd_w5regular_">1</span>, <span class="thesansmonocd_w5regular_">3</span>, <span class="thesansmonocd_w5regular_">5</span>, and <span class="thesansmonocd_w5regular_">6</span> of the matched text <span class="codeannotation" aria-label="annotation2">❷</span>. (These groups are the area code, first three digits, last four digits, and extension.)</p>
</section>
<section type="division" aria-labelledby="sec29">
<h4 class="h1" id="calibre_link-1658"><span id="calibre_link-219"></span><span class="sans_futura_std_heavy_oblique_bi_">Step 4: Join the Matches into a String</span></h4>
<p class="tni">Now that you have the email addresses and phone numbers as a list of strings in <span class="thesansmonocd_w5regular_">matches</span>, you want to put them on the clipboard. The <span class="thesansmonocd_w5regular_">pyperclip.copy()</span> function takes only a single string value, not a list of strings, so you must call the <span class="thesansmonocd_w5regular_">join()</span> method on <span class="thesansmonocd_w5regular_">matches</span>.</p>
<p class="tx">Make your program look like the following:</p>
<pre class="pre"><code class="calibre9">import pyperclip, re

phone_re = re.compile(r'''(
--<var class="calibre20">snip</var>--
for groups in email_re.findall(text):
    matches.append(groups[0])

<b class="calibre10"># Copy results to the clipboard.</b>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1186" aria-label="209"></span><b class="calibre10">if len(matches) &gt; 0:</b>
<b class="calibre10">    pyperclip.copy('\n'.join(matches))</b>
<b class="calibre10">    print('Copied to clipboard:')</b>
<b class="calibre10">    print('\n'.join(matches))</b>
<b class="calibre10">else:</b>
<b class="calibre10">    print('No phone numbers or email addresses found.')</b>
</code></pre>
<p class="tx">To make it easier to see that the program is working, we also print any matches you find to the terminal window. If no phone numbers or email addresses were found, the program tells the user this.</p>
<p class="tx">To test your program, open your web browser to the No Starch Press contact page at <i class="calibre5"><a href="https://nostarch.com/contactus" class="calibre1">https://<wbr></wbr>nostarch<wbr></wbr>.com<wbr></wbr>/contactus</a></i> press <small class="calibre4">CTRL</small>-A to select all the text on the page, and press <small class="calibre4">CTRL</small>-C to copy it to the clipboard. When you run this program, the output should look something like this:</p>
<pre class="pre"><code class="calibre9">Copied to clipboard:
800-555-7240
415-555-9900
415-555-9950
info@nostarch.com
media@nostarch.com
academic@nostarch.com
info@nostarch.com
</code></pre>
<p class="tx">You can modify this script to search for mailing addresses, social media handles, and many other types of text patterns.</p>
</section>
<section type="division" aria-labelledby="sec30">
<h4 class="h1" id="calibre_link-1659"><span id="calibre_link-220"></span><span class="sans_futura_std_heavy_oblique_bi_">Ideas for Similar Programs</span></h4>
<p class="tni">Identifying patterns of text (and possibly substituting them with the <span class="thesansmonocd_w5regular_">sub()</span> method) has many different potential applications. For example, you could do the following:</p>
<ul class="ul">
<li class="bl">Find website URLs that begin with <i class="calibre5">http://</i> or <i class="calibre5">https://</i>.</li>
<li class="bl">Clean up dates in different date formats (such as 3/14/2030, 03-14-2030, and 2030/3/14) by replacing them with dates in a single, standard format.</li>
<li class="bl">Remove sensitive information such as Social Security numbers or credit card numbers.</li>
<li class="bl">Find common typos, such as multiple spaces between words, accidentally accidentally repeated words, or multiple exclamation marks at the ends of sentences. Those are annoying!!</li>
</ul>
</section>
</section>
<section type="division" aria-labelledby="sec31">
<h3 class="h" id="calibre_link-1660"><span id="calibre_link-221"></span><span class="sans_futura_std_bold_b_">Humre: A Module for Human-Readable Regexes</span></h3>
<p class="tni">Code is read far more often than it’s written, so it’s important for your code to be readable. But the punctuation-dense syntax of regular expressions can be hard for even experienced programmers to read. To solve this, the third-party Humre Python module takes the good ideas of verbose mode even further by using human-readable, plain-English names to create readable regex code. You can install Humre by following the instructions in <span>Appendix A</span>.</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-945" aria-label="210"></span>Let’s go back to the <span class="thesansmonocd_w5regular_">r'\d{3}-\d{3}-\d{4}'</span> phone number example from the beginning of this chapter. The functions and constants in Humre can produce the same regex string with plain English:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">from humre import *</b>
&gt;&gt;&gt; <b class="calibre10">phone_regex = exactly(3, DIGIT) + '-' + exactly(3, DIGIT) + '-' + exactly(4, DIGIT)</b>
&gt;&gt;&gt; <b class="calibre10">phone_regex</b>
'\\d{3}-\\d{3}-\\d{4}'
</code></pre>
<p class="tx">Humre’s constants (like <span class="thesansmonocd_w5regular_">DIGIT</span>) contain strings, and Humre’s functions (like <span class="thesansmonocd_w5regular_">exactly()</span>) return strings. Humre doesn’t replace the <span class="thesansmonocd_w5regular_">re</span> module. Rather, it produces regex strings that can be passed to <span class="thesansmonocd_w5regular_">re.compile()</span>:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import re</b>
&gt;&gt;&gt; <b class="calibre10">pattern = re.compile(phone_regex)</b>
&gt;&gt;&gt; <b class="calibre10">pattern.search('My number is 415-555-4242')</b>
&lt;re.Match object; span=(13, 25), match='415-555-4242'&gt;
</code></pre>
<p class="tx">Humre has constants and functions for each feature of regular expression syntax. You can then concatenate the constants and returned strings like any other string. For example, here are Humre’s constants for the shorthand character classes:</p>
<ul class="ul">
<li class="bl"><span class="thesansmonocd_w5regular_">DIGIT</span> and <span class="thesansmonocd_w5regular_">NONDIGIT</span> represent <span class="thesansmonocd_w5regular_">r'\d'</span> and <span class="thesansmonocd_w5regular_">r'\D'</span>, respectively.</li>
<li class="bl"><span class="thesansmonocd_w5regular_">WORD</span> and <span class="thesansmonocd_w5regular_">NONWORD</span> represent <span class="thesansmonocd_w5regular_">r'\w'</span> and <span class="thesansmonocd_w5regular_">r'\W'</span>, respectively.</li>
<li class="bl"><span class="thesansmonocd_w5regular_">WHITESPACE</span> and <span class="thesansmonocd_w5regular_">NONWHITESPACE</span> represent <span class="thesansmonocd_w5regular_">r'\s'</span> and <span class="thesansmonocd_w5regular_">r'\S'</span>, respectively.</li>
</ul>
<p class="tx">A common source of regex bugs is forgetting which characters need to be escaped. You can use Humre’s constants instead of typing the escaped character yourself. For example, say you want to match a single-digit floating-point number with one digit after the decimal point, like <span class="thesansmonocd_w5regular_">'0.9'</span> or <span class="thesansmonocd_w5regular_">'4.5'</span>. However, if you use the regex string <span class="thesansmonocd_w5regular_">r'\d.\d'</span>, you might not realize that the dot matches a period (as in <span class="thesansmonocd_w5regular_">'4.5'</span>) but also matches any other character (as in <span class="thesansmonocd_w5regular_">'4A5'</span>).</p>
<p class="tx">Instead, use Humre’s <span class="thesansmonocd_w5regular_">PERIOD</span> constant, which contains the string <span class="thesansmonocd_w5regular_">r'\.'</span>. The expression <span class="thesansmonocd_w5regular_">DIGIT</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">PERIOD</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">DIGIT</span> evaluates to <span class="thesansmonocd_w5regular_">r'\d\.\d'</span> and makes it much more obvious what the regex intends to match.</p>
<p class="tx">The following Humre constants exist for escaped characters:</p>

<pre class="pre1"><code class="calibre9">PERIOD     OPEN_PAREN  OPEN_BRACKET    PIPE
DOLLAR_SIGN CLOSE_PAREN CLOSE_BRACKET   CARET
QUESTION_MARK   ASTERISK    OPEN_BRACE  TILDE
HASHTAG     PLUS        CLOSE_BRACE 
AMPERSAND   MINUS       BACKSLASH   
</code></pre>
<p class="tx">There are also constants for <span class="thesansmonocd_w5regular_">NEWLINE</span>, <span class="thesansmonocd_w5regular_">TAB</span>, <span class="thesansmonocd_w5regular_">QUOTE</span>, and <span class="thesansmonocd_w5regular_">DOUBLE_QUOTE</span>. Back references from <span class="thesansmonocd_w5regular_">r'\1'</span> to <span class="thesansmonocd_w5regular_">r'\99'</span> are represented as <span class="thesansmonocd_w5regular_">BACK_1</span> to <span class="thesansmonocd_w5regular_">BACK_99</span>.</p>
<p class="tx">However, you’ll make the largest readability gains by using Humre’s functions. Table 9-2 shows these functions and their equivalent regular expression syntax.</p>
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-936" aria-label="211"></span>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-726"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 9-2:</span></span> <span class="sans_futura_std_book_">Humre Functions</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Humre function</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Regex string</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">group('A')</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">r'(A)'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">optional('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">r'A?'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">either('A', 'B', 'C')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">r'A|B|C'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">exactly(3, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A{3}'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">between(3, 5, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A{3,5}'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">at_least(3, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A{3,}'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">at_most(3, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A{,3}'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">chars('A-Z')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'[A-Z]'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">nonchars('A-Z')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'[^A-Z]'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">zero_or_more('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A*'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">zero_or_more_lazy('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A*?'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">one_or_more('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A+'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">one_or_more_lazy('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A+?'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">starts_with('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'^A'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">ends_with('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'A$'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">starts_and_ends_with('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'^A$'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">named_group('name', 'A')</span></p></td>
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">'(?P&lt;name&gt;A)'</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">Humre also has several convenience functions that combine common pairs of function calls. For example, instead of using <span class="thesansmonocd_w5regular_">optional(group('A'))</span> to create <span class="thesansmonocd_w5regular_">'(A)?'</span>, you can simply call <span class="thesansmonocd_w5regular_">optional_group('A')</span>. Table 9-3 has the full list of Humre convenience functions.</p>
<table class="basic-table">
<caption class="calibre12"><p class="tt" id="calibre_link-727"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 9-3:</span></span> <span class="sans_futura_std_book_">Humre Convenience Functions</span></p></caption>

<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Convenience function</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Function equivalent</span></p></th>
<th class="tch" scope="col"><p class="tch1"><span class="sans_futura_std_bold_b_">Regex string</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">optional_group('A')</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">optional(group('A'))</span></p></td>
<td class="tbf"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A)?'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">group_either('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">group(either('A', 'B', 'C'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A|B|C)'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">exactly_group(3, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">exactly(3, group('A'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A){3}'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">between_group(3, 5, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">between(3, 5, group('A'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A){3,5}'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">at_least_group (3, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">at_least(3, group('A'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A){3,}'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">at_most_group (3, 'A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">at_most(3, group('A'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A){,3}'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">zero_or_more_group('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">zero_or_more(group('A'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A)*'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">zero_or_more_lazy_group('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">zero_or_more_lazy(group('A'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A)*?'</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">one_or_more_group('A')</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">one_or_more(group('A'))</span></p></td>
<td class="tb"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A)+'</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">one_or_more_lazy_group('A')</span></p></td>
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">one_or_more_lazy(group('A'))</span></p></td>
<td class="tbl"><p class="tch1"><span class="thesansmonocd_w5regular_">'(A)+?'</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-910" aria-label="212"></span>All of Humre’s functions except <span class="thesansmonocd_w5regular_">either()</span> and <span class="thesansmonocd_w5regular_">group_either()</span> allow you to pass multiple strings to automatically join them. This means that calling <span class="thesansmonocd_w5regular_">group(DIGIT, PERIOD, DIGIT)</span> produces the same regex string as <span class="thesansmonocd_w5regular_">group(DIGIT</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">PERIOD</span> <span class="thesansmonocd_w5regular_">+</span> <span class="thesansmonocd_w5regular_">DIGIT)</span>. They both return the regex string <span class="thesansmonocd_w5regular_">r'(\d\.\d)'</span>.</p>
<p class="tx">Finally, Humre has constants for common regex patterns:</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">ANY_SINGLE</span> The <span class="thesansmonocd_w5regular_">.</span> pattern that matches any single character (except newlines)</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">ANYTHING_LAZY</span> The lazy <span class="thesansmonocd_w5regular_">.*?</span> zero or more pattern</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">ANYTHING_GREEDY</span> The greedy <span class="thesansmonocd_w5regular_">.*</span> zero or more pattern</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">SOMETHING_LAZY</span> The lazy <span class="thesansmonocd_w5regular_">.+?</span> one or more pattern</p>
<p class="listplain"><span class="sans_thesansmonocd_w7bold_b_">SOMETHING_GREEDY</span> The greedy <span class="thesansmonocd_w5regular_">.+</span> one or more pattern</p>
<p class="tx">The readability of regex written with Humre becomes more obvious when you consider large, complicated regular expressions. Let’s rewrite the phone number regex from the previous phone number extractor project using Humre:</p>
<pre class="pre"><code class="calibre9">import re
from humre import *
phone_regex = group(
    optional_group(either(exactly(3, DIGIT),  # Area code
                          OPEN_PAREN + exactly(3, DIGIT) + CLOSE_PAREN)),
    optional(group_either(WHITESPACE, '-', PERIOD)),  # Separator
    group(exactly(3, DIGIT)),  # First three digits
    group_either(WHITESPACE, '-', PERIOD),  # Separator
    group(exactly(4, DIGIT)),  # Last four digits
    optional_group(  # Extension
      zero_or_more(WHITESPACE),
      group_either('ext', 'x', r'ext\.'),
      zero_or_more(WHITESPACE),
      group(between(2, 5, DIGIT))
      )
    )

pattern = re.compile(phone_regex)
match = pattern.search('My number is 415-555-1212.')
print(match.group())
</code></pre>
<p class="tx">When you run this program, the output is this:</p>
<pre class="pre"><code class="calibre9">415-555-1212</code></pre>
<p class="tx">This code is much more verbose than even the verbose mode regex. It helps to import Humre using the <span class="thesansmonocd_w5regular_">from humre import *</span> syntax so that you don’t need to put <span class="thesansmonocd_w5regular_">humre.</span> before every function and constant. But the length of the code doesn’t matter as much as the readability.</p>
<p class="tx"><span role="doc-pagebreak" type="pagebreak" id="calibre_link-1183" aria-label="213"></span>You can switch your existing regular expressions to Humre code by calling the <span class="thesansmonocd_w5regular_">humre.parse()</span> function, which returns a string of Python source code:</p>
<pre class="pre"><code class="calibre9">&gt;&gt;&gt; <b class="calibre10">import humre</b>
&gt;&gt;&gt; <b class="calibre10">humre.parse(r'\d{3}-\d{3}-\d{4}')</b>
"exactly(3, DIGIT) + '-' + exactly(3, DIGIT) + '-' + exactly(4, DIGIT)"
</code></pre>
<p class="tx">When combined with a modern editor such as PyCharm or Visual Studio Code, Humre offers several further advantages:</p>
<ul class="ul">
<li class="bl">You can indent your code to make it obvious which parts of the regex contain which other parts.</li>
<li class="bl">Your editor’s parentheses matching works.</li>
<li class="bl">Your editor’s syntax highlighting works.</li>
<li class="bl">Your editor’s linter and type hints tool picks up typos.</li>
<li class="bl">Your editor’s autocomplete fills in the function and constant names.</li>
<li class="bl">Humre handles raw strings and escaping for you.</li>
<li class="bl">You can put Python comments alongside your Humre code.</li>
<li class="bl">Typos cause more helpful error messages.</li>
</ul>
<p class="tx">Many experienced programmers will object to using anything other than the standard, complicated, unreadable regular expression syntax. As programmer Peter Bhat Harkins once said, “One of the most irritating things programmers do regularly is feel so good about learning a hard thing that they don’t look for ways to make it easy, or even oppose things that would do so.”</p>
<p class="tx">However, if a co-worker objects to your use of Humre, you can simply print the underlying regex string that your Humre code generates and put it back into your source code. For example, the contents of the <span class="thesansmonocd_w5regular_">phone_regex</span> variable in the phone number extractor project are as follows:</p>
<pre class="pre"><code class="calibre9">r'((\d{3}|\(\d{3}\))?(\s|-|\.)?(\d{3})(\s|-|\.)(\d{4})(\s*(ext|x|ext\.)\s*(\d{2,5}))?)'</code></pre>
<p class="tx">Your co-worker is welcome to use this regular expression string if they feel it is more appropriate.</p>
</section>
<section type="conclusion" role="doc-conclusion" aria-labelledby="sec32">
<h3 class="h" id="calibre_link-1661"><span id="calibre_link-222"></span><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">While a computer can search for text quickly, it must be told precisely what to look for. Regular expressions allow you to specify the pattern of characters you are looking for, rather than the exact text itself. In fact, some word processing and spreadsheet applications provide find-and-replace features that allow you to search using regular expressions. The punctuation-heavy syntax of regular expressions is composed of qualifiers that detail what to match and quantifiers that detail how many to match.</p>
<p class="tx">The <span class="thesansmonocd_w5regular_">re</span> module that comes with Python lets you compile a regex string into a <span class="thesansmonocd_w5regular_">Pattern</span> object. These objects have several methods: <span class="thesansmonocd_w5regular_">search()</span>, to find <span role="doc-pagebreak" type="pagebreak" id="calibre_link-1662" aria-label="214"></span>a single match; <span class="thesansmonocd_w5regular_">findall()</span>, to find all matching instances; and <span class="thesansmonocd_w5regular_">sub()</span>, to do a find-and-replace substitution of text.</p>
<p class="tx">You can find out more in the official Python documentation at <i class="calibre5"><a href="https://docs.python.org/3/library/re.html" class="calibre1">https://<wbr></wbr>docs<wbr></wbr>.python<wbr></wbr>.org<wbr></wbr>/3<wbr></wbr>/library<wbr></wbr>/re<wbr></wbr>.html</a></i>. Another useful resource is the tutorial website <i class="calibre5"><a href="https://www.regular-expressions.info" class="calibre1">https://<wbr></wbr>www<wbr></wbr>.regular<wbr></wbr>-expressions<wbr></wbr>.info</a></i>. The Humre page on the Python Package Index is <i class="calibre5"><a href="https://pypi.org/project/Humre/" class="calibre1">https://<wbr></wbr>pypi<wbr></wbr>.org<wbr></wbr>/project<wbr></wbr>/Humre<wbr></wbr>/</a></i>.</p>
</section>
<section type="division" aria-labelledby="sec33">
<h3 class="h" id="calibre_link-1663"><span id="calibre_link-223"></span><span class="sans_futura_std_bold_b_">Practice Questions</span></h3>
<p class="listnumber">  1.  What is the function that returns <span class="thesansmonocd_w5regular_">Regex</span> objects?</p>
<p class="listnumber">  2.  Why are raw strings often used when creating <span class="thesansmonocd_w5regular_">Regex</span> objects?</p>
<p class="listnumber">  3.  What does the <span class="thesansmonocd_w5regular_">search()</span> method return?</p>
<p class="listnumber">  4.  How do you get the actual strings that match the pattern from a <span class="thesansmonocd_w5regular_">Match</span> object?</p>
<p class="listnumber">  5.  In the regex created from <span class="thesansmonocd_w5regular_">r'(\d\d\d)-(\d\d\d-\d\d\d\d)'</span>, what does group <span class="thesansmonocd_w5regular_">0</span> cover? Group <span class="thesansmonocd_w5regular_">1</span>? Group <span class="thesansmonocd_w5regular_">2</span>?</p>
<p class="listnumber">  6.  Parentheses and periods have specific meanings in regular expression syntax. How would you specify that you want a regex to match actual parentheses and period characters?</p>
<p class="listnumber">  7.  The <span class="thesansmonocd_w5regular_">findall()</span> method returns a list of strings or a list of tuples of strings. What makes it return one or the other?</p>
<p class="listnumber">  8.  What does the <span class="thesansmonocd_w5regular_">|</span> character signify in regular expressions?</p>
<p class="listnumber">  9.  What two things does the <span class="thesansmonocd_w5regular_">?</span> character signify in regular expressions?</p>
<p class="listnumber">10.  What is the difference between the <span class="thesansmonocd_w5regular_">+</span> and <span class="thesansmonocd_w5regular_">*</span> characters in regular expressions?</p>
<p class="listnumber">11.  What is the difference between <span class="thesansmonocd_w5regular_">{3}</span> and <span class="thesansmonocd_w5regular_">{3,5}</span> in regular expressions?</p>
<p class="listnumber">12.  What do the <span class="thesansmonocd_w5regular_">\d</span>, <span class="thesansmonocd_w5regular_">\w</span>, and <span class="thesansmonocd_w5regular_">\s</span> shorthand character classes signify in regular expressions?</p>
<p class="listnumber">13.  What do the <span class="thesansmonocd_w5regular_">\D</span>, <span class="thesansmonocd_w5regular_">\W</span>, and <span class="thesansmonocd_w5regular_">\S</span> shorthand character classes signify in regular expressions?</p>
<p class="listnumber">14.  What is the difference between the <span class="thesansmonocd_w5regular_">.*</span> and <span class="thesansmonocd_w5regular_">.*?</span> regular expressions?</p>
<p class="listnumber">15.  What is the character class syntax to match all numbers and lowercase letters?</p>
<p class="listnumber">16.  How do you make a regular expression case-insensitive?</p>
<p class="listnumber">17.  What does the <span class="thesansmonocd_w5regular_">.</span> character normally match? What does it match if <span class="thesansmonocd_w5regular_">re.DOTALL</span> is passed as the second argument to <span class="thesansmonocd_w5regular_">re.compile()</span>?</p>
<p class="listnumber">18.  If <span class="thesansmonocd_w5regular_">num_re</span> <span class="thesansmonocd_w5regular_">=</span> <span class="thesansmonocd_w5regular_">re.compile(r'\d+')</span>, what will <span class="thesansmonocd_w5regular_">num_re.sub('X', '12 drummers, 11 pipers, five rings, 3 hens')</span> return?</p>
<p class="listnumber">19.  What does passing <span class="thesansmonocd_w5regular_">re.VERBOSE</span> as the second argument to <span class="thesansmonocd_w5regular_">re.compile()</span> allow you to do?</p>
</section>
<section type="division" aria-labelledby="sec34">
<span role="doc-pagebreak" type="pagebreak" id="calibre_link-1285" aria-label="215"></span>
<h3 class="h" id="calibre_link-1664"><span id="calibre_link-224"></span><span class="sans_futura_std_bold_b_">Practice Programs</span></h3>
<p class="tni">For practice, write programs to do the following tasks.</p>
<section type="division" aria-labelledby="sec35">
<h4 class="h1" id="calibre_link-1665"><span id="calibre_link-225"></span><span class="sans_futura_std_heavy_oblique_bi_">Strong Password Detection</span></h4>
<p class="tni">Write a function that uses regular expressions to make sure the password string it is passed is strong. A strong password has several rules: it must be at least eight characters long, contain both uppercase and lowercase characters, and have at least one digit. Hint: It’s easier to test the string against multiple regex patterns than to try to come up with a single regex that can validate all the rules.</p>
</section>
<section type="division" aria-labelledby="sec36">
<h4 class="h1" id="calibre_link-1666"><span id="calibre_link-226"></span><span class="sans_futura_std_heavy_oblique_bi_">Regex Version of the strip() Method</span></h4>
<p class="tni">Write a function that takes a string and does the same thing as the <span class="thesansmonocd_w5regular_">strip()</span> string method. If no other arguments are passed other than the string to strip, then the function should remove whitespace characters from the beginning and end of the string. Otherwise, the function should remove the characters specified in the second argument to the function.</p>
</section>
</section>
</section>
</div>


</div>


<style>.atbs-nav{display:flex;flex-wrap:wrap;gap:.5rem;align-items:center;justify-content:space-between;margin:1rem 0;padding:.7rem .8rem;border:1px solid #cfd8dc;border-radius:10px;background:#f6fbfd;font:14px/1.35 system-ui,-apple-system,sans-serif;}.atbs-nav-center{color:#455a64;font-weight:600;}.atbs-nav-link{text-decoration:none;color:#0b5b6b;background:#e6f3f7;border:1px solid #c7dfe7;border-radius:7px;padding:.42rem .55rem;display:inline-block;}.atbs-nav-link:hover{background:#d9edf3;}.atbs-nav-disabled{opacity:.55;cursor:not-allowed;}</style><nav class='atbs-nav' aria-label='Chapter pagination'><a class='atbs-nav-link' href='../workbook/chapter8.html' aria-label='Previous chapter'>&larr; Workbook Chapter 8</a><span class='atbs-nav-center'><a class='atbs-nav-link' href='../index.html'>Contents</a> Book Chapter 9</span><a class='atbs-nav-link' href='../workbook/chapter9.html' aria-label='Next chapter'>Workbook Chapter 9 &rarr;</a></nav></body></html>